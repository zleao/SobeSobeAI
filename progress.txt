## 2026-02-02 - Issue #1: Backend Development - Trump Selection Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/rounds/current/trump endpoint for selecting trump suit
- Created SelectTrumpRequest and SelectTrumpResponse DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Only allows party player to select trump (returns 403 Forbidden for others)
- Validates game exists and round is in TrumpSelection phase (returns 409 Conflict if wrong phase)
- Validates trump selection rules:
  - Only Hearts can be selected before dealing (selectedBeforeDealing = true)
  - Any suit can be selected after receiving 2 cards (selectedBeforeDealing = false)
- Calculates trick value based on trump suit and timing:
  - Hearts before dealing: 4 points (blind trump)
  - Hearts after 2 cards: 2 points
  - Diamonds/Clubs/Spades before dealing: 2 points
  - Diamonds/Clubs/Spades after 2 cards: 1 point
- Updates round with trump selection and moves to next phase:
  - If selected before dealing: moves to Dealing phase
  - If selected after 2 cards: moves to PlayerDecisions phase
- Returns trump details including roundId, trumpSuit, trumpSelectedBeforeDealing, trickValue
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found), 403 Forbidden (not party player), 400 Bad Request (invalid trump rules), 409 Conflict (wrong phase)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/SelectTrumpRequest.cs (trump suit and timing input)
- Created: backend/SobeSobe.Api/DTOs/SelectTrumpResponse.cs (trump selection result)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/rounds/current/trump endpoint after start game endpoint)

### Learnings
- Trump selection has complex rules based on timing (before/after dealing) and suit
- Hearts before dealing (blind trump) doubles trick values from 2→4 (Hearts) or 1→2 (others)
- Party player is determined when game starts based on dealer position (counter-clockwise)
- Round.Status progression: TrumpSelection → Dealing (if blind) or PlayerDecisions (if after cards)
- EF Core Include() with OrderByDescending().Take(1) efficiently loads most recent round
- Switch expressions provide clean syntax for trick value calculation based on suit
- RoundStatus enum: TrumpSelection (1) → Dealing (0) or PlayerDecisions (2)
- Testing workflow: register → login (2 users) → create game → join game → start game → select trump (party player only)
- Tested edge cases: Hearts before dealing (4 pts), Diamonds after dealing (1 pt), invalid suit before dealing (400), selecting twice (409)
- Phase validation prevents trump selection at wrong time (already selected or game not started)

### Next steps
- Implement player decision endpoint (POST /api/games/{id}/rounds/current/play-decision) - opt-in/opt-out
- Implement card dealing logic (deal 2 cards initially, then 3 more after decisions)
- Implement card exchange endpoint (POST /api/games/{id}/rounds/current/exchange-cards)
- Implement play card endpoint (POST /api/games/{id}/rounds/current/play-card)
- Implement get game state endpoint (GET /api/games/{id}/state)
- Implement score history endpoint (GET /api/games/{id}/scores)
- Add real-time notifications for game events (gRPC/SignalR)

## 2026-02-02 - Issue #1: Backend Development - Cancel Game Endpoint Implementation

### What was implemented
- Implemented DELETE /api/games/{id} endpoint for canceling games before they start
- Endpoint requires authentication (.RequireAuthorization())
- Only allows game creator to cancel (returns 403 Forbidden for non-creators)
- Validates game exists and is in Waiting status (cannot cancel started games)
- Deletes the entire game including all player sessions (cascading delete)
- Returns 200 OK with success message on successful cancellation
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found), 403 Forbidden (not creator), 400 Bad Request (game already started)

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added DELETE /api/games/{id} endpoint after leave game endpoint)

### Learnings
- Results.StatusCode(403) returns 403 Forbidden status code for authorization failures
- EF Core Remove() on Game entity triggers cascading delete for related PlayerSessions
- DELETE HTTP method follows RESTful conventions for resource deletion
- Authorization checks: authentication (valid token) + ownership (creator only)
- Game status validation prevents canceling in-progress games
- Cascading delete configured in ApplicationDbContext removes child entities automatically
- Minimal API .WithName() provides friendly name for OpenAPI documentation
- Testing workflow: register → login (2 users) → create game (user 1) → join game (user 2) → try cancel as user 2 (403) → cancel as user 1 (200) → verify game deleted (404)

### Next steps
- Implement start game endpoint (POST /api/games/{id}/start) - transitions game to InProgress
- Implement game action endpoints (trump selection, play decision, card exchange, play card)
- Implement game state endpoint (GET /api/games/{id}/state)
- Implement score history endpoint (GET /api/games/{id}/scores)
- Add real-time notifications for game events (gRPC/SignalR)

## 2026-02-02 - Issue #1: Backend Development - Join Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/join endpoint for joining existing games
- Endpoint requires authentication (.RequireAuthorization())
- Validates game exists and is in Waiting status (cannot join started games)
- Checks if user is already in the game (returns 409 Conflict)
- Checks if game is full (returns 400 Bad Request)
- Automatically assigns next available position (0-4)
- Creates PlayerSession with 20 starting points for joining user
- Returns join response with gameId and full PlayerSession details
- Tested successfully: create game → join game → verify duplicate join (409) → verify full game (400)

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/join endpoint)

### Learnings
- Results.Conflict() returns 409 status code for duplicate resource operations
- HashSet<int> efficient for checking occupied positions in small collections
- EF Core Include() loads navigation properties needed for validation (PlayerSessions)
- Next available position algorithm: iterate 0-4 until finding unoccupied position
- Game status check prevents joining games that have already started
- PlayerSession created with same pattern as game creator (20 points, IsActive=true)
- JoinedAt timestamp tracks when each player joined the game
- Position assignment maintains seat order for game flow (dealer rotation)
- Error handling: 401 Unauthorized (no token), 404 Not Found (user/game), 409 Conflict (already joined), 400 Bad Request (game full or started)
- Testing workflow: register → login → create game (user 2) → join game (user 3) → verify game has 2 players → test duplicate join → test full game

### Next steps
- Implement leave game endpoint (POST /api/games/{id}/leave)
- Implement cancel game endpoint (DELETE /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management
- Add real-time notifications for game events (gRPC/SignalR)
## 2026-02-02 - Issue #1: Backend Development - Get Game Details Endpoint Implementation

### What was implemented
- Implemented GET /api/games/{id} endpoint for fetching full game details
- Endpoint accepts Guid game ID as route parameter
- Uses EF Core Include() to eagerly load CreatedBy user and PlayerSessions with User navigation properties
- Returns comprehensive GameResponse with full game state and player list
- Returns 404 Not Found if game doesn't exist
- Endpoint is public (no authentication required) to allow viewing game details
- Fixed null reference warnings in both list games and get game details endpoints by adding null-forgiving operators (!)
- Tested successfully: create game → fetch details → verify 404 for non-existent game

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added GET /api/games/{id} endpoint, fixed null reference warnings)

### Learnings
- Route parameter constraints with {id:guid} enforce Guid type in URL
- FirstOrDefaultAsync() with Include() eagerly loads navigation properties
- Null-forgiving operator (!) suppresses compiler warnings for navigation properties loaded with Include()
- EF Core Include() with ThenInclude() ensures nested navigation properties (Game → PlayerSessions → User) are loaded
- Minimal API results: Results.Ok() for 200, Results.NotFound() for 404
- Players ordered by Position property for consistent display order
- GameResponse DTO reused from create game endpoint for consistency
- Public endpoints allow browsing game state before joining (transparency for users)
- Testing workflow: register → login → create game → get game details → verify 404

### Next steps
- Implement join game endpoint (POST /api/games/{id}/join)
- Implement leave game endpoint (POST /api/games/{id}/leave)
- Implement cancel game endpoint (DELETE /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management

## 2026-02-02 - Issue #1: Backend Development - Create Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games endpoint for creating new games
- Created CreateGameRequest DTO (validates maxPlayers 2-5)
- Created GameResponse and PlayerSessionResponse DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Creates Game entity with Waiting status and creator as first player
- Automatically creates PlayerSession for game creator at position 0 with 20 starting points
- Returns comprehensive GameResponse with game details and player list
- Tested successfully: register → login → create game workflow

### Files changed
- Created: backend/SobeSobe.Api/DTOs/CreateGameRequest.cs (maxPlayers validation)
- Created: backend/SobeSobe.Api/DTOs/GameResponse.cs (game and player session response DTOs)
- Modified: backend/SobeSobe.Api/Program.cs (added create game endpoint, imported SobeSobe.Core.Enums)

### Learnings
- Game entity uses CreatedByUserId property (not CreatedBy as initially attempted)
- Game entity uses CurrentDealerPosition property (not CurrentDealerIndex)
- GameStatus enum value 0 = Waiting (enum serialized as integer in JSON)
- Game creator automatically joins as first player at position 0
- PlayerSession tracks currentPoints (starts at 20), isActive, and consecutiveRoundsOut
- Response includes full player details with username, displayName, and avatarUrl from User entity
- JWT authentication extracts userId from "sub" claim and verifies user exists before creating game
- Returns 201 Created with Location header pointing to /api/games/{id}
- Comprehensive error handling: 401 if not authenticated, 404 if user not found

### Next steps
- Implement join game endpoint (POST /api/games/{id}/join)
- Implement list games endpoint (GET /api/games)
- Implement get game details endpoint (GET /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management

## 2026-02-02 - Issue #1: Backend Development - List Games Endpoint Implementation

### What was implemented
- Implemented GET /api/games endpoint for listing available games with pagination and filtering
- Created ListGamesResponse DTO with pagination metadata (page, pageSize, totalPages, totalItems)
- Created GameListItem, UserSummary, PlayerSummary DTOs for clean response structure
- Endpoint supports optional query parameters: status (filter by game status), createdBy (filter by creator), page (default 1), pageSize (default 20, max 100)
- Uses EF Core Include() to eagerly load CreatedBy user and PlayerSessions with User navigation properties
- Orders games by creation date (newest first) for consistent pagination
- Returns games with full player list (username, displayName, position) ordered by position
- Endpoint is public (no authentication required) to allow browsing available games
- Tested successfully: pagination (page 1/2 with pageSize 2), filtering (status=0), total count calculations

### Files changed
- Created: backend/SobeSobe.Api/DTOs/ListGamesResponse.cs (response DTOs for list games endpoint)
- Modified: backend/SobeSobe.Api/Program.cs (added GET /api/games endpoint before POST /api/games)

### Learnings
- EF Core Include() with ThenInclude() enables eager loading nested navigation properties (Game → PlayerSessions → User)
- Query filters applied before pagination for accurate total count and page count calculations
- Math.Ceiling() calculates total pages from total items and page size
- Skip() and Take() implement offset-based pagination in EF Core
- Validation: page < 1 defaults to 1, pageSize outside 1-100 range defaults to 20
- OrderByDescending(g => g.CreatedAt) ensures consistent ordering across pagination (newest games first)
- Public endpoint allows lobby browsing without authentication (join requires auth)
- PlayerSessions.Count gives current player count efficiently
- LINQ Select() projects Game entities to GameListItem DTOs with nested UserSummary and PlayerSummary objects
- OrderBy(ps => ps.Position) ensures players listed in seat order (0, 1, 2, 3, 4)
- Pagination metadata includes all information needed for UI pagination controls (current page, total pages, total items)

### Next steps
- Implement get game details endpoint (GET /api/games/{id})
- Implement join game endpoint (POST /api/games/{id}/join)
- Implement leave game endpoint (POST /api/games/{id}/leave)
- Implement cancel game endpoint (DELETE /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management

## 2026-02-02 - Issue #1: Backend Development - Get Current User Endpoint Implementation

### What was implemented
- Implemented GET /api/auth/user endpoint requiring authentication
- Endpoint uses .RequireAuthorization() to enforce JWT Bearer token
- Extracts user ID from JWT "sub" claim
- Finds user in database and returns UserResponse DTO
- Returns 401 Unauthorized without valid JWT token
- Returns 404 Not Found if user doesn't exist
- Configured JWT authentication to disable inbound claim mapping (MapInboundClaims = false)
- Set NameClaimType and RoleClaimType for proper claim handling

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added get current user endpoint, updated JWT configuration)

### Learnings
- .RequireAuthorization() in Minimal API enforces authentication on endpoints
- MapInboundClaims = false prevents ASP.NET from converting JWT claim names (sub → NameIdentifier)
- JWT "sub" claim accessed via JwtRegisteredClaimNames.Sub
- HttpContext.User.FindFirst() retrieves claim from authenticated user
- NameClaimType = JwtRegisteredClaimNames.UniqueName sets default name claim
- Invoke-RestMethod with -Headers @{ "Authorization" = "Bearer $token" } sends JWT token
- Returns 401 if no token provided, 404 if user not found, 200 OK with user data if authenticated
- Test workflow: login → get user (with token) → get user (without token, should fail)

### Next steps
- Add background job to clean up expired refresh tokens periodically
- Implement remaining user management endpoints (get profile by ID, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)
- Implement game state machine for game lifecycle

## 2026-02-02 - Issue #1: Backend Development - Logout Endpoint Implementation

### What was implemented
- Implemented POST /api/auth/logout endpoint for logging out users
- Created LogoutRequest DTO
- Logout endpoint revokes refresh token by calling RevokeRefreshTokenAsync
- Returns 200 OK with success message
- Tested successfully: logout revokes refresh token, subsequent refresh attempts fail with 400 Bad Request

### Files changed
- Created: backend/SobeSobe.Api/DTOs/LogoutRequest.cs (refresh token input for logout)
- Modified: backend/SobeSobe.Api/Program.cs (added logout endpoint)

### Learnings
- Logout endpoint simple but critical for security
- Revoking refresh token prevents further token refresh attempts
- Client should discard access token locally on logout (access tokens can't be revoked server-side)
- Returns 200 OK even if refresh token not found (idempotent operation)
- Test workflow: login → logout → try refresh (should fail with 400)

### Next steps
- Implement get current user endpoint (GET /api/auth/user) with [Authorize] attribute
- Add background job to clean up expired refresh tokens
- Implement remaining user management endpoints (get profile, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)

## 2026-02-02 - Issue #1: Backend Development - Token Refresh Implementation

### What was implemented
- Implemented POST /api/auth/refresh endpoint for refreshing access tokens
- Created RefreshToken entity to store refresh tokens in database
- Created RefreshTokenRequest and RefreshTokenResponse DTOs
- Extended JwtTokenService with methods: GenerateAndStoreRefreshTokenAsync, ValidateRefreshTokenAsync, RevokeRefreshTokenAsync, RevokeAllUserRefreshTokensAsync
- Updated ApplicationDbContext to include RefreshTokens DbSet with indexes on Token (unique), UserId, and ExpiresAt
- Created EF Core migration "AddRefreshToken" to add RefreshTokens table
- Updated login endpoint to store refresh tokens in database
- Changed JwtTokenService from Singleton to Scoped lifetime (requires DbContext)
- Refresh tokens expire after 7 days, old refresh tokens automatically revoked on refresh
- Tested successfully: login generates stored refresh token, refresh endpoint returns new tokens, old refresh token properly revoked

### Files changed
- Created: backend/SobeSobe.Core/Entities/RefreshToken.cs (entity with UserId FK, Token, ExpiresAt, CreatedAt, RevokedAt, IsActive property)
- Created: backend/SobeSobe.Api/DTOs/RefreshTokenRequest.cs (refresh token input)
- Created: backend/SobeSobe.Api/DTOs/RefreshTokenResponse.cs (new access token and refresh token)
- Modified: backend/SobeSobe.Core/Entities/User.cs (added RefreshTokens navigation property)
- Modified: backend/SobeSobe.Infrastructure/Data/ApplicationDbContext.cs (added RefreshTokens DbSet, configured entity relationships)
- Modified: backend/SobeSobe.Api/Services/JwtTokenService.cs (added database storage and validation methods, constructor now requires ApplicationDbContext)
- Modified: backend/SobeSobe.Api/Program.cs (changed JwtTokenService to Scoped, updated login to use GenerateAndStoreRefreshTokenAsync, added refresh endpoint)
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/20260202133418_AddRefreshToken.cs (EF Core migration)

### Learnings
- Refresh tokens must be stored in database for revocation and security audit trail
- Service lifetime matters: JwtTokenService changed from Singleton to Scoped to access DbContext
- RefreshToken entity tracks creation time, expiration, and revocation with IsActive computed property
- Token revocation: old refresh token revoked immediately when new tokens issued
- EF Core Include() method loads User navigation property when validating refresh token
- Unique index on Token column prevents duplicate refresh tokens
- CASCADE delete on UserId FK ensures orphaned refresh tokens deleted when user deleted
- Test workflow: register → login (get tokens) → refresh (get new tokens) → try old token (should fail)
- 7-day refresh token expiry balances security and user experience
- FirstOrDefaultAsync with Token lookup efficient with unique index

### Next steps
- Implement logout endpoint (POST /api/auth/logout) with token revocation
- Implement get current user endpoint (GET /api/auth/user) with [Authorize] attribute
- Add background job to clean up expired refresh tokens periodically
- Implement remaining user management endpoints (get profile, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)

## 2026-02-02 - Issue #1: Backend Development - User Login with JWT Authentication

### What was implemented
- Implemented POST /api/auth/login endpoint with JWT token generation
- Created JwtTokenService for generating access tokens (15-min expiry) and refresh tokens
- Created LoginRequest and LoginResponse DTOs
- Configured JWT Bearer authentication in Program.cs with token validation
- Added JWT configuration to appsettings.json (secret, issuer, audience)
- Login endpoint accepts username OR email, verifies password, updates LastLoginAt timestamp
- Returns 200 OK with access token, refresh token, token type, expiry, and user data on success
- Returns 400 Bad Request on invalid credentials
- Tested successfully: login with username, login with email, invalid password handling

### Files changed
- Created: backend/SobeSobe.Api/Services/JwtTokenService.cs (JWT token generation using HS256, 15-min access token, secure refresh token)
- Created: backend/SobeSobe.Api/DTOs/LoginRequest.cs (username or email + password)
- Created: backend/SobeSobe.Api/DTOs/LoginResponse.cs (access token, refresh token, token type, expiry, user data)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added Microsoft.AspNetCore.Authentication.JwtBearer 10.0.2, System.IdentityModel.Tokens.Jwt 8.4.0)
- Modified: backend/SobeSobe.Api/appsettings.json (added JWT configuration: Secret, Issuer, Audience)
- Modified: backend/SobeSobe.Api/Program.cs (configured JWT authentication, added login endpoint)

### Learnings
- JwtSecurityTokenHandler.WriteToken() generates compact JWT token string
- SymmetricSecurityKey with HS256 algorithm for signing tokens (secret must be at least 32 bytes)
- JWT claims use JwtRegisteredClaimNames (Sub for user ID, UniqueName for username, Email, Jti for token ID)
- Access tokens short-lived (15 min), refresh tokens long-lived (simplified implementation, production should store in DB)
- Refresh token generated using RandomNumberGenerator.GetBytes() for crypto-secure randomness
- Login endpoint updates LastLoginAt timestamp for user activity tracking
- FirstOrDefaultAsync with OR condition searches username OR email in single query
- Authentication middleware must be called before Authorization: UseAuthentication() then UseAuthorization()
- JWT configuration in appsettings.json: Secret (min 32 chars), Issuer (API identifier), Audience (client identifier)
- Build succeeded, all tests pass, login endpoint tested successfully with username and email

### Next steps
- Implement token refresh endpoint (POST /api/auth/refresh)
- Implement logout endpoint (POST /api/auth/logout) with token revocation
- Implement get current user endpoint (GET /api/auth/user) with [Authorize] attribute
- Store refresh tokens in database for security and revocation
- Add claims-based authorization for protected endpoints
- Implement remaining user management endpoints (get profile, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)

## 2026-02-02 - Issue #13: Initialize monorepo project structure

### What was implemented
- Created root repository directory structure (frontend/, backend/, infrastructure/, docs/, .github/workflows/)
- Initialized Angular 19+ project in /frontend with Tailwind CSS v3 support
- Initialized .NET 10 solution with multiple projects:
  - SobeSobe.Api (Minimal API)
  - SobeSobe.Core (Domain models and interfaces)
  - SobeSobe.Infrastructure (Data access layer)
  - SobeSobe.AppHost (Aspire orchestration)
  - SobeSobe.Tests (Test project)
- Created comprehensive documentation:
  - README.md with project overview and setup instructions
  - LICENSE (MIT)
  - CONTRIBUTING.md with development guidelines
  - docs/game-rules.md (placeholder)
  - docs/api-specification.md (placeholder)
  - docs/architecture.md (placeholder)
- Added comprehensive .gitignore for .NET, Angular, and tooling

### Files changed
- Created: .gitignore, README.md, LICENSE, CONTRIBUTING.md
- Created: frontend/ directory with Angular 19 app, Tailwind CSS v3, PostCSS config
- Created: backend/ directory with .NET 10 solution and 5 projects
- Created: docs/ directory with placeholder documentation files
- Created: infrastructure/, .github/workflows/ directories (empty, ready for next tasks)

### Learnings
- .NET Aspire templates are installed via `dotnet new install Aspire.ProjectTemplates` not workload
- Tailwind CSS v4 requires @tailwindcss/postcss plugin, but Angular build has compatibility issues - using v3 instead
- Angular 19 uses standalone components by default
- Frontend builds successfully, backend builds and tests pass

### Next steps
- Issue #9: Setup .NET Aspire for local development (AppHost is created, needs configuration)
- Issue #12: Write comprehensive game rules documentation
- Issue #11: Define REST API and gRPC contracts

## 2026-02-02 - Issue #9: Setup .NET Aspire for local development

### What was implemented
- Configured .NET Aspire AppHost to orchestrate the backend API service
- Created SobeSobe.ServiceDefaults project with telemetry, health checks, and service discovery
- Integrated Aspire ServiceDefaults into SobeSobe.Api for automatic health checks and observability
- Added `AddServiceDefaults()` and `MapDefaultEndpoints()` to API for health check endpoints
- Created comprehensive Aspire usage documentation (docs/aspire-usage.md)
- Aspire Dashboard provides real-time monitoring, logs, traces, and metrics
- Used Aspire 9.5.2 with .NET 10 SDK (no workload required, NuGet packages only)

### Files changed
- Modified: backend/SobeSobe.AppHost/AppHost.cs (configured API service orchestration)
- Modified: backend/SobeSobe.AppHost/SobeSobe.AppHost.csproj (added Aspire.Hosting.AppHost package)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added ServiceDefaults reference)
- Modified: backend/SobeSobe.Api/Program.cs (integrated Aspire service defaults)
- Created: backend/SobeSobe.ServiceDefaults/ (Aspire service defaults project)
- Modified: backend/SobeSobe.sln (added ServiceDefaults project)
- Created: docs/aspire-usage.md (comprehensive Aspire documentation)

### Learnings
- .NET Aspire 9.5.2 is the latest stable version compatible with .NET 10 SDK
- Aspire 13.x versions don't exist yet; documentation was referencing future versions
- Aspire.Hosting.Sqlite and Aspire.Hosting.NodeJs packages had version compatibility issues
- Removed `IsAspireHost` property to avoid deprecated workload detection in .NET 10
- Simplified AppHost by deferring SQLite integration until database schema is designed (Issue #16)
- Deferred Angular/Node.js integration in AppHost to future iteration
- Used `AddExecutable` as workaround for project reference metadata generation issues
- ServiceDefaults provides automatic health checks at `/health` and `/alive` endpoints
- Aspire Dashboard accessible at https://localhost:17032 or http://localhost:15283
- All builds and tests pass successfully

### Next steps
- Issue #16: Design database schema (will integrate SQLite with Aspire after schema is ready)
- Issue #12: Write comprehensive game rules documentation
- Issue #11: Define REST API and gRPC contracts
- Future: Integrate Angular frontend with AppHost using Aspire.Hosting.NodeJs

## 2026-02-02 - Issue #12: Write comprehensive game rules documentation

### What was implemented
- Created comprehensive game rules documentation in docs/game-rules.md with 750+ lines of detailed content
- Documented complete game setup: deck composition, card ranking, initial state
- Documented round phase: dealer selection, party player role, trump selection (before/after dealing), player decisions, card exchange
- Documented trick-taking phase: follow suit rules, trump escalation, mandatory Ace of trump rule, winning conditions
- Documented scoring phase: point reduction for tricks won, penalties for zero tricks, party player double penalties
- Added glossary of Portuguese terms (Manilha, Copas às escuras, Cortar, etc.)
- Created detailed game state transition diagram showing flow from game start to end
- Provided 3-player example game with 5 complete rounds demonstrating all mechanics
- Documented 10 edge cases and special scenarios with resolutions
- Defined comprehensive validation rules for trump selection, player decisions, card exchange, trick-taking, and scoring
- Added UI/UX requirements for score table visualization
- Included detailed examples and tables for trick values, penalties, and scoring calculations

### Files changed
- Modified: docs/game-rules.md (replaced placeholder with 750+ lines of comprehensive documentation)

### Learnings
- The game has significant strategic depth from trump selection timing, opt-in/opt-out mechanics, and card exchange
- Party player role carries both privilege (choosing trump) and risk (double penalties)
- Mandatory Ace of trump rule adds interesting tactical constraint
- Trump escalation rule (must play higher trump when trump is led) creates forced play scenarios
- Consecutive sit-out tracking (max 2 rounds) prevents passive play
- Clubs trump forces all players to play, creating high-participation rounds
- Prize calculation (€0.05 per remaining point) provides clear monetary incentive
- Score table UI should use visual indicators (bold for dealer, underline for party player, colors for point changes)
- Edge cases around trump Ace + following suit need clear documentation
- Negative points are valid and common near game end

### Next steps
- Issue #16: Design database schema and domain models (now have complete rules to inform entity design)
- Issue #11: Define REST API and gRPC contracts (rules documentation will guide endpoint design)
- Issue #15: Create UI/UX wireframes and mockups (rules documentation includes score table requirements)

## 2026-02-02 - Issue #16: Design database schema and domain models

### What was implemented
- Created comprehensive database schema documentation in docs/database-schema.md (25KB+)
- Designed complete Entity Relationship Diagram (ERD) with 7 core entities
- Implemented all domain models in SobeSobe.Core project with EF Core annotations
- Created enums: GameStatus, RoundStatus, TrumpSuit, ScoreReason
- Created Card value object with validation and rank value methods
- Created 7 entity classes: User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory
- Documented all relationships and foreign keys (1:N, with CASCADE/RESTRICT rules)
- Defined comprehensive data validation rules for all entities
- Designed performance indexes for common query patterns
- Planned data archival strategy (90-day archival for completed games)
- Documented migration strategy from SQLite → Azure SQL Database

**Entity Highlights:**
- User: Authentication, profile, cumulative statistics (games played, wins, prize won)
- Game: Game instance lifecycle (Waiting → InProgress → Completed/Abandoned)
- Round: Round lifecycle with dealer/party player tracking, trump selection, trick value
- PlayerSession: Player participation with position, points, consecutive rounds out tracking
- Hand: JSON storage for current and initial cards (5-card hands)
- Trick: JSON storage for cards played in order, lead and winner tracking
- ScoreHistory: Complete audit trail of all point changes with reasons

**Key Design Decisions:**
- JSON storage for cards (flexible, easy to query)
- Normalized 3NF design with minimal redundancy
- Composite indexes for common patterns (GameId + RoundNumber, GameId + Position)
- ScoreHistory provides complete audit trail (GameStart, TricksWon, Penalties)
- Archival strategy keeps database performant (90-day moving window)
- Clear migration path from SQLite → SQL Server for production

### Files changed
- Created: docs/database-schema.md (comprehensive schema documentation)
- Created: backend/SobeSobe.Core/Enums/ (GameStatus, RoundStatus, TrumpSuit, ScoreReason)
- Created: backend/SobeSobe.Core/ValueObjects/Card.cs (card value object)
- Created: backend/SobeSobe.Core/Entities/ (User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory)
- Deleted: backend/SobeSobe.Core/Class1.cs (placeholder file)

### Learnings
- JSON columns in SQLite stored as TEXT, with System.Text.Json for serialization
- EF Core [NotMapped] attribute allows helper properties (e.g., Cards list from CardsJson)
- Foreign keys use required/nullable Guid to enforce relationships
- Composite indexes support queries like "find all rounds for game ordered by round number"
- ScoreHistory pattern provides complete audit trail and enables "undo" scenarios
- Archival strategy critical for long-term performance (millions of completed games)
- SQLite → SQL Server migration requires testing JSON functions and DateTime handling
- Card value object uses record type for value semantics and immutability
- Navigation properties use ICollection<T> for lazy loading support
- Range attributes on enums (0-4 for Position) prevent invalid data

### Next steps
- Issue #11: Define REST API and gRPC contracts (now have complete entity models)
- Create ApplicationDbContext and EF Core migrations
- Implement repository interfaces and patterns
- Add integration tests for entity validation rules

## 2026-02-02 - Issue #11: Define REST API and gRPC contracts

### What was implemented
- Created comprehensive API specification documentation in docs/api-specification.md (60KB+)
- Documented complete REST API with OpenAPI-style specification covering authentication, game management, and gameplay endpoints
- Created gRPC service definition file (backend/SobeSobe.Api/Protos/game-events.proto) for real-time bidirectional communication
- Defined 5 authentication endpoints (register, login, refresh, logout, get user)
- Defined 3 user management endpoints (get profile, update profile, get statistics)
- Defined 7 game lobby endpoints (list games, create, get details, join, leave, cancel, start)
- Defined 5 game action endpoints (get state, select trump, play decision, exchange cards, play card, get scores)
- Created gRPC service with 3 RPC methods (Subscribe, SendAction, Heartbeat) and 13 event types
- Documented 25+ error codes with detailed error response standards
- Defined comprehensive validation rules for all game actions aligned with game rules
- Included detailed request/response examples for all endpoints
- Documented error response format with contextual details for debugging

**API Architecture:**
- REST API for stateless operations (authentication, game management, query operations)
- gRPC for real-time bidirectional events (card plays, trick completion, score updates, game state changes)
- OAuth 2.0 / OpenID Connect with JWT Bearer tokens (15-min access, 7-day refresh)
- Consistent error response format with error codes, messages, details, and timestamps
- API versioning with /api/v1 prefix

**gRPC Events:**
- PlayerJoined/Left, GameStarted, RoundStarted
- TrumpSelected, CardDealt, PlayDecision, CardsExchanged
- CardPlayed, TrickCompleted, RoundCompleted, GameCompleted
- PlayerTurn (with action_required and timeout), Error events

**Validation Highlights:**
- Trump selection: Only party player, Hearts-only before dealing (4-point tricks), Clubs forces all players
- Player decisions: Max 2 consecutive sit-outs, party/dealer cannot opt out
- Card exchange: 0-3 cards, cannot exchange Ace of trump
- Trick-taking: Follow suit, trump escalation, mandatory Ace of trump rules
- Scoring: Tricks reduce points, zero-trick penalties (5/10/20 points), party player double penalty

### Files changed
- Modified: docs/api-specification.md (replaced placeholder with 60KB+ comprehensive API documentation)
- Created: backend/SobeSobe.Api/Protos/game-events.proto (gRPC service definition with 240+ lines)

### Learnings
- REST API ideal for stateless operations (create game, join, query state), gRPC for real-time push notifications
- Error responses should include contextual details (e.g., cards in hand that satisfy rule for "must follow suit" errors)
- JWT short-lived access tokens (15 min) + long-lived refresh tokens (7 days) balance security and UX
- gRPC oneof payload pattern allows single GameEvent message with polymorphic payloads for different event types
- Validation rules must enforce game rules (trump escalation, Ace of trump, follow suit) at API boundary
- API versioning (/api/v1) allows future breaking changes without disrupting existing clients
- Protobuf map<string, string> for error details provides flexibility for different error scenarios
- Heartbeat RPC keeps long-lived gRPC connections alive and detects disconnections
- Card exchange endpoint returns full updated hand to avoid client-side state synchronization bugs
- GET /games endpoint needs pagination to handle potentially large game lists

### Next steps
- Issue #14: Configure GitHub Actions for CI/CD (setup automated build/test/deploy)
- Issue #15: Create UI/UX wireframes and mockups (now have complete API contracts to inform frontend design)
- Implement REST endpoints in SobeSobe.Api with ASP.NET Core Minimal API
- Implement gRPC service in SobeSobe.Api with Grpc.AspNetCore
- Create DTO classes for request/response models
- Implement JWT authentication with ASP.NET Core Identity

## 2026-02-02 - Issue #14: Configure GitHub Actions for CI/CD

### What was implemented
- Created comprehensive GitHub Actions CI/CD pipeline with 3 workflows
- **Frontend CI** (.github/workflows/frontend-ci.yml):
  - Runs on push/PR to main/develop when frontend code changes
  - Installs Node.js 20, runs ESLint, Prettier, builds Angular app
  - Executes unit tests with code coverage (Karma/Jasmine)
  - Uploads coverage to Codecov
  - Builds production bundle and uploads artifacts (7-day retention)
- **Backend CI** (.github/workflows/backend-ci.yml):
  - Runs on push/PR to main/develop when backend code changes
  - Sets up .NET 10 SDK, restores NuGet packages
  - Runs dotnet format check, builds solution in Release mode
  - Executes unit tests with XPlat Code Coverage
  - Uploads coverage to Codecov
  - Publishes API and uploads artifacts (7-day retention)
- **Deploy to Azure** (.github/workflows/deploy-azure.yml):
  - Runs on push to main or manual trigger
  - Builds frontend and backend independently
  - Deploys frontend to Azure Static Web Apps
  - Deploys backend to Azure App Service
  - Runs smoke tests for both frontend and backend health endpoints
- Updated rontend/package.json with 	est:ci and lint scripts
- Added CI/CD status badges to README.md
- Created comprehensive CI/CD documentation (docs/ci-cd.md) with:
  - Workflow descriptions, triggers, and requirements
  - GitHub secrets configuration guide
  - Branch protection rules recommendations
  - Code quality checks configuration
  - Troubleshooting guide for common CI/CD issues
  - Future enhancement roadmap

**CI/CD Architecture:**
- Path-based triggers: frontend and backend CI only run when respective code changes
- Artifact-based deployment: Build once, deploy multiple environments
- Smoke tests: Automated health checks after deployment
- Code coverage reporting: Integrated with Codecov for coverage tracking
- Branch protection: Enforces status checks before merging to main

### Files changed
- Created: .github/workflows/frontend-ci.yml (frontend build, lint, test pipeline)
- Created: .github/workflows/backend-ci.yml (backend build, test pipeline)
- Created: .github/workflows/deploy-azure.yml (Azure deployment pipeline)
- Modified: frontend/package.json (added test:ci and lint scripts)
- Modified: README.md (added CI/CD status badges)
- Created: docs/ci-cd.md (comprehensive CI/CD documentation)

### Learnings
- GitHub Actions path filters optimize CI runs by only triggering when relevant code changes
- Artifacts with 7-day retention provide debugging capability without long-term storage costs
- dotnet format with --verify-no-changes enforces consistent code style in CI
- Angular test:ci script needs --watch=false and --browsers=ChromeHeadless for CI environments
- Codecov action works with both frontend (lcov.info) and backend (coverage.cobertura.xml) formats
- Smoke tests should run after deployment to catch issues before users encounter them
- Branch protection rules prevent merging without passing status checks
- Azure Static Web Apps deployment uses API token, App Service uses service principal credentials
- continue-on-error: true allows workflows to report issues without blocking (ESLint, Prettier)
- Workflow artifacts enable manual testing and rollback scenarios

### Next steps
- Configure GitHub secrets (AZURE_STATIC_WEB_APPS_API_TOKEN, AZURE_CREDENTIALS, CODECOV_TOKEN)
- Enable branch protection rules on main branch
- Issue #10: Create Azure infrastructure with Bicep (provision Azure resources for deployment)
- Issue #15: Create UI/UX wireframes and mockups (design frontend user interfaces)
- Add integration tests to CI pipeline
- Configure Dependabot for automated security updates
- Add CodeQL security scanning

## 2026-02-02 - Issue #10: Create Azure infrastructure with Bicep

### What was implemented
- Created comprehensive Azure infrastructure as code using Bicep templates
- **Main orchestration file** (main.bicep): Orchestrates all resources at subscription scope
- **Module files**:
  - key-vault.bicep: Azure Key Vault for secrets with RBAC, soft delete, purge protection
  - app-service.bicep: App Service Plan + App Service for .NET 10 backend with managed identity
  - static-web-app.bicep: Azure Static Web Apps for Angular frontend with GitHub integration
  - monitoring.bicep: Log Analytics Workspace + Application Insights for observability
  - database.bicep: Azure SQL Server + Database (production only, dev/staging use SQLite)
- **Parameter files**: dev.parameters.json, staging.parameters.json, prod.parameters.json
- **Deployment script** (deploy.ps1): PowerShell script with validation, what-if, and deployment
- **Documentation** (infrastructure/README.md): Comprehensive guide with architecture, costs, troubleshooting

**Resource Configuration:**
- Dev: B1 App Service (~$13/mo), Free Static Web App, SQLite, ~$15-20/mo total
- Staging: B2 App Service (~$54/mo), Standard Static Web App, SQLite, ~$70-75/mo total
- Prod: P1v3 App Service (~$328/mo), Standard Static Web App, Azure SQL Basic, ~$355-365/mo total

**Security Features:**
- Managed identity for App Service → Key Vault access (no secrets in app settings)
- RBAC authorization on Key Vault (Key Vault Secrets User role)
- HTTPS enforcement, TLS 1.2 minimum, FTPS disabled
- Soft delete and purge protection on Key Vault
- Azure SQL accessible only from Azure services

**Deployment Features:**
- What-if mode for validation without creating resources
- Outputs saved to outputs/{env}-outputs.json for GitHub secrets configuration
- Unique resource naming using uniqueString() to avoid conflicts
- Environment-specific SKUs and retention policies
- Health check endpoints configured on App Service

### Files changed
- Created: infrastructure/main.bicep (main orchestration)
- Created: infrastructure/modules/key-vault.bicep
- Created: infrastructure/modules/app-service.bicep
- Created: infrastructure/modules/static-web-app.bicep
- Created: infrastructure/modules/monitoring.bicep
- Created: infrastructure/modules/database.bicep
- Created: infrastructure/parameters/dev.parameters.json
- Created: infrastructure/parameters/staging.parameters.json
- Created: infrastructure/parameters/prod.parameters.json
- Created: infrastructure/deploy.ps1 (deployment script)
- Created: infrastructure/README.md (comprehensive documentation)
- Created: infrastructure/outputs/.gitignore (ignore deployment outputs)
- Created: infrastructure/outputs/.gitkeep (track directory)

### Learnings
- Bicep targetScope 'subscription' allows creating resource groups in the same template
- Conditional modules (if environmentName == 'prod') generate BCP318 warnings but work correctly at deployment
- uniqueString(subscription().id, environmentName) ensures globally unique resource names
- System-assigned managed identity + RBAC is more secure than Key Vault access policies
- Static Web Apps Free tier sufficient for dev, Standard needed for custom domains (staging/prod)
- App Service linuxFxVersion 'DOTNETCORE|10.0' for .NET 10 runtime
- Azure SQL Basic tier (2GB) costs ~$5/mo, good starting point for production
- SQLite suitable for dev/staging, allows fast iteration without Azure costs
- Log Analytics workspace required for Application Insights (IngestionMode: 'LogAnalytics')
- deploy.ps1 script provides friendly UX with colored output, validation, what-if support

### Next steps
- Deploy infrastructure to Azure: `.\infrastructure\deploy.ps1 -Environment dev -WhatIf`
- Configure GitHub secrets from deployment outputs (see docs/ci-cd.md)
- Issue #15: Create UI/UX wireframes and mockups (design frontend user interfaces)
- Implement Entity Framework Core DbContext and migrations (Issue #3)
- Implement REST API endpoints and gRPC services (Issue #1)

## 2026-02-02 - Issue #3: Database and Persistence - Initial EF Core Setup

### What was implemented
- Created ApplicationDbContext with DbSet properties for all 7 entities (User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory)
- Configured entity relationships with OnModelCreating: defined foreign keys, navigation properties, and cascade behaviors
- Added EF Core packages: Microsoft.EntityFrameworkCore.Sqlite (10.0.2) and Microsoft.EntityFrameworkCore.Design (10.0.2)
- Configured DbContext in SobeSobe.Api with SQLite connection string (Data Source=sobesobe.db)
- Created initial EF Core migration '20260202132251_InitialCreate' with all tables, indexes, and constraints
- Applied migration successfully - database created with 7 tables and 19 indexes
- Verified all builds and tests pass

### Files changed
- Created: backend/SobeSobe.Infrastructure/Data/ApplicationDbContext.cs (198 lines, complete DbContext with entity configurations)
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/20260202132251_InitialCreate.cs (EF Core migration)
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/20260202132251_InitialCreate.Designer.cs
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/ApplicationDbContextModelSnapshot.cs
- Modified: backend/SobeSobe.Infrastructure/SobeSobe.Infrastructure.csproj (added EF Core packages and Core project reference)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added Microsoft.EntityFrameworkCore.Design package)
- Modified: backend/SobeSobe.Api/Program.cs (registered ApplicationDbContext with dependency injection)
- Modified: backend/SobeSobe.Api/appsettings.json (added DefaultConnection connection string)
- Deleted: backend/SobeSobe.Infrastructure/Class1.cs (placeholder file)
- Created: backend/SobeSobe.Api/sobesobe.db (SQLite database file, 176KB)

### Learnings
- EF Core 10.0.2 is the latest version compatible with .NET 10 SDK
- DbContext registration in Program.cs uses builder.Services.AddDbContext<ApplicationDbContext>() with UseSqlite()
- Entity navigation property names must match exactly in DbContext configuration (e.g., CreatedGames vs GamesCreated)
- JSON columns in SQLite use HasColumnName() to map JSON properties (CardsJson → ""Cards"" column)
- entity.Ignore() used for computed/unmapped properties (Cards list from CardsJson)
- Composite indexes created with HasIndex(e => new { e.Property1, e.Property2 })
- Unique constraints enforced with IsUnique() on indexes
- CASCADE delete for child entities (PlayerSessions, Hands, Tricks, ScoreHistory)
- RESTRICT delete for reference entities (User references from Round dealer/party player)
- SQLite WAL mode enabled automatically by EF Core for better concurrency
- Migration created from Infrastructure project with --output-dir Data/Migrations
- Database update applies all pending migrations and creates __EFMigrationsHistory table
- All 19 indexes created successfully for optimizing common query patterns

### Next steps
- Implement repository interfaces and patterns in SobeSobe.Infrastructure
- Create unit tests for ApplicationDbContext and entity validation
- Implement game logic service layer in SobeSobe.Core
- Start implementing REST API endpoints for authentication and game management (Issue #1)
- Integrate ApplicationDbContext with Aspire orchestration for dev workflow

## 2026-02-02 - Issue #1: Backend Development - User Registration Tracer Bullet

### What was implemented
- Created DTOs: RegisterUserRequest and UserResponse for API contracts
- Implemented PasswordHasher service using PBKDF2 with SHA256 (100,000 iterations, 16-byte salt, 32-byte hash)
- Created POST /api/users/register endpoint with full validation
- Endpoint validates username uniqueness, email uniqueness, and password strength
- Returns 201 Created with user data on success, 400 Bad Request on validation errors
- Tested endpoint manually - registration works, duplicate username/email validation works

### Files changed
- Created: backend/SobeSobe.Api/DTOs/RegisterUserRequest.cs (validation attributes for username, email, password, displayName)
- Created: backend/SobeSobe.Api/DTOs/UserResponse.cs (user data without password hash)
- Created: backend/SobeSobe.Api/Services/PasswordHasher.cs (PBKDF2 password hashing and verification)
- Modified: backend/SobeSobe.Api/Program.cs (added user registration endpoint, removed weather forecast placeholder)

### Learnings
- Minimal API endpoints use dependency injection - ApplicationDbContext injected directly into endpoint lambda
- Results.Created() returns 201 with Location header pointing to new resource
- Results.BadRequest() returns 400 with error message in response body
- PasswordHasher.HashPassword() generates 64-byte base64 string (16-byte salt + 32-byte hash)
- EF Core Any() method efficient for checking existence without loading full entity
- DTOs keep API contracts separate from domain models
- required keyword on DTO properties enforces non-null values
- RegularExpression validation attribute enforces username format (alphanumeric + underscore)
- StringLength validation ensures password meets minimum 8-character requirement
- EmailAddress validation attribute validates email format

### Next steps
- Implement user login endpoint with JWT token generation (Issue #1)
- Implement repository pattern to abstract data access from endpoints
- Add unit tests for PasswordHasher service
- Add integration tests for user registration endpoint
- Implement remaining user management endpoints (get profile, update profile, get statistics)
- Start implementing game management endpoints (create game, join game, list games)


## 2026-02-02 - Issue #1: Backend Development - Leave Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/leave endpoint for leaving games before they start
- Endpoint requires authentication (.RequireAuthorization())
- Validates game exists and is in Waiting status (cannot leave started games)
- Checks if user is actually in the game (returns 404 if not)
- Ownership transfer: If game creator leaves and other players remain, ownership transfers to next player by position
- Automatic game deletion: If last player leaves, the game is deleted
- Sets LeftAt timestamp before removing PlayerSession
- Returns 200 OK with success message
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found or user not in game), 400 Bad Request (game already started)

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/leave endpoint)

### Learnings
- CreatedByUserId property tracks game ownership and can be transferred when creator leaves
- EF Core Remove() on PlayerSession deletes the record from database
- Ownership transfer logic finds next player by position using OrderBy(ps => ps.Position).First()
- Game deletion when last player leaves prevents orphaned games
- LeftAt timestamp provides audit trail for player departures
- PlayerSessions.Count check before removal determines if game should be deleted
- Where clause excludes current leaving user when finding next owner
- Error scenarios: not in game (404), game already started (400), unauthorized (401)
- Testing workflow: register → login (2 users) → create game (user 1) → join game (user 2) → leave game (user 2) → verify player count reduced

### Next steps
- Implement cancel game endpoint (DELETE /api/games/{id}) - allows creator to delete game
- Implement start game endpoint (POST /api/games/{id}/start) - transitions game to InProgress and creates first round
- Test ownership transfer scenario (creator leaves, verify new owner)
- Test last player leaving scenario (verify game deletion)
- Implement game state machine for round and trick management
- Add real-time notifications for game events (gRPC/SignalR)


## 2026-02-02 - Issue #1: Backend Development - Start Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/start endpoint for starting games
- Endpoint requires authentication (.RequireAuthorization())
- Only allows game creator to start (returns 403 Forbidden for non-creators)
- Validates game exists and is in Waiting status (cannot start already started games)
- Validates minimum 2 players required to start game
- Randomly selects dealer from active players
- Automatically determines party player (counter-clockwise from dealer)
- Creates first Round entity with:
  - RoundNumber = 1
  - DealerUserId and PartyPlayerUserId set
  - Status = TrumpSelection (waiting for party player to select trump)
  - TrumpSuit = Hearts (default, will be changed by party player)
  - TrickValue = 0 (will be set after trump selection)
- Updates Game entity:
  - Status = InProgress
  - StartedAt timestamp
  - CurrentRoundNumber = 1
  - CurrentDealerPosition set to dealer's position
- Returns StartGameResponse with gameId, status, startedAt, currentRoundNumber, currentDealerPosition
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found), 403 Forbidden (not creator), 400 Bad Request (already started or < 2 players)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/StartGameResponse.cs (response DTO with game start details)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/start endpoint after cancel game endpoint)

### Learnings
- Random dealer selection uses Random.Next() to pick from active players
- Party player calculation: counter-clockwise means next position in circular order (dealerPosition + 1) % playerCount
- Round.Status starts at TrumpSelection, waiting for party player to choose trump
- Round.TrumpSuit has default value (Hearts) that will be overwritten during trump selection
- Round.TrickValue is 0 initially and will be set to 1, 2, or 4 after trump selection (based on suit and timing)
- Game.CurrentDealerPosition stores the position (0-4) of the current dealer for round management
- FirstOrDefaultAsync with Include() loads navigation properties needed for game state queries
- Dealer and party player selection logic handles non-sequential player positions by sorting first
- Circular indexing: (index + 1) % count wraps around to 0 when reaching end of list
- Testing workflow: register → login (2 users) → create game → join game → start game (201) → verify status (InProgress) → try start again (400)
- Edge cases tested: start with 1 player (400), start already started game (400), non-creator tries to start (403)

### Next steps
- Implement trump selection endpoint (POST /api/games/{id}/rounds/current/trump)
- Implement player decision endpoint (POST /api/games/{id}/rounds/current/play-decision)
- Implement card dealing logic (deal 2 cards initially, then 3 more after decisions)
- Implement card exchange endpoint (POST /api/games/{id}/rounds/current/exchange-cards)
- Implement play card endpoint (POST /api/games/{id}/rounds/current/play-card)
- Implement get game state endpoint (GET /api/games/{id}/state)
- Add real-time notifications for game events (gRPC/SignalR)

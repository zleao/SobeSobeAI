## 2026-02-02 - Issue #13: Initialize monorepo project structure

### What was implemented
- Created root repository directory structure (frontend/, backend/, infrastructure/, docs/, .github/workflows/)
- Initialized Angular 19+ project in /frontend with Tailwind CSS v3 support
- Initialized .NET 10 solution with multiple projects:
  - SobeSobe.Api (Minimal API)
  - SobeSobe.Core (Domain models and interfaces)
  - SobeSobe.Infrastructure (Data access layer)
  - SobeSobe.AppHost (Aspire orchestration)
  - SobeSobe.Tests (Test project)
- Created comprehensive documentation:
  - README.md with project overview and setup instructions
  - LICENSE (MIT)
  - CONTRIBUTING.md with development guidelines
  - docs/game-rules.md (placeholder)
  - docs/api-specification.md (placeholder)
  - docs/architecture.md (placeholder)
- Added comprehensive .gitignore for .NET, Angular, and tooling

### Files changed
- Created: .gitignore, README.md, LICENSE, CONTRIBUTING.md
- Created: frontend/ directory with Angular 19 app, Tailwind CSS v3, PostCSS config
- Created: backend/ directory with .NET 10 solution and 5 projects
- Created: docs/ directory with placeholder documentation files
- Created: infrastructure/, .github/workflows/ directories (empty, ready for next tasks)

### Learnings
- .NET Aspire templates are installed via `dotnet new install Aspire.ProjectTemplates` not workload
- Tailwind CSS v4 requires @tailwindcss/postcss plugin, but Angular build has compatibility issues - using v3 instead
- Angular 19 uses standalone components by default
- Frontend builds successfully, backend builds and tests pass

### Next steps
- Issue #9: Setup .NET Aspire for local development (AppHost is created, needs configuration)
- Issue #12: Write comprehensive game rules documentation
- Issue #11: Define REST API and gRPC contracts

## 2026-02-02 - Issue #9: Setup .NET Aspire for local development

### What was implemented
- Configured .NET Aspire AppHost to orchestrate the backend API service
- Created SobeSobe.ServiceDefaults project with telemetry, health checks, and service discovery
- Integrated Aspire ServiceDefaults into SobeSobe.Api for automatic health checks and observability
- Added `AddServiceDefaults()` and `MapDefaultEndpoints()` to API for health check endpoints
- Created comprehensive Aspire usage documentation (docs/aspire-usage.md)
- Aspire Dashboard provides real-time monitoring, logs, traces, and metrics
- Used Aspire 9.5.2 with .NET 10 SDK (no workload required, NuGet packages only)

### Files changed
- Modified: backend/SobeSobe.AppHost/AppHost.cs (configured API service orchestration)
- Modified: backend/SobeSobe.AppHost/SobeSobe.AppHost.csproj (added Aspire.Hosting.AppHost package)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added ServiceDefaults reference)
- Modified: backend/SobeSobe.Api/Program.cs (integrated Aspire service defaults)
- Created: backend/SobeSobe.ServiceDefaults/ (Aspire service defaults project)
- Modified: backend/SobeSobe.sln (added ServiceDefaults project)
- Created: docs/aspire-usage.md (comprehensive Aspire documentation)

### Learnings
- .NET Aspire 9.5.2 is the latest stable version compatible with .NET 10 SDK
- Aspire 13.x versions don't exist yet; documentation was referencing future versions
- Aspire.Hosting.Sqlite and Aspire.Hosting.NodeJs packages had version compatibility issues
- Removed `IsAspireHost` property to avoid deprecated workload detection in .NET 10
- Simplified AppHost by deferring SQLite integration until database schema is designed (Issue #16)
- Deferred Angular/Node.js integration in AppHost to future iteration
- Used `AddExecutable` as workaround for project reference metadata generation issues
- ServiceDefaults provides automatic health checks at `/health` and `/alive` endpoints
- Aspire Dashboard accessible at https://localhost:17032 or http://localhost:15283
- All builds and tests pass successfully

### Next steps
- Issue #16: Design database schema (will integrate SQLite with Aspire after schema is ready)
- Issue #12: Write comprehensive game rules documentation
- Issue #11: Define REST API and gRPC contracts
- Future: Integrate Angular frontend with AppHost using Aspire.Hosting.NodeJs

## 2026-02-02 - Issue #12: Write comprehensive game rules documentation

### What was implemented
- Created comprehensive game rules documentation in docs/game-rules.md with 750+ lines of detailed content
- Documented complete game setup: deck composition, card ranking, initial state
- Documented round phase: dealer selection, party player role, trump selection (before/after dealing), player decisions, card exchange
- Documented trick-taking phase: follow suit rules, trump escalation, mandatory Ace of trump rule, winning conditions
- Documented scoring phase: point reduction for tricks won, penalties for zero tricks, party player double penalties
- Added glossary of Portuguese terms (Manilha, Copas às escuras, Cortar, etc.)
- Created detailed game state transition diagram showing flow from game start to end
- Provided 3-player example game with 5 complete rounds demonstrating all mechanics
- Documented 10 edge cases and special scenarios with resolutions
- Defined comprehensive validation rules for trump selection, player decisions, card exchange, trick-taking, and scoring
- Added UI/UX requirements for score table visualization
- Included detailed examples and tables for trick values, penalties, and scoring calculations

### Files changed
- Modified: docs/game-rules.md (replaced placeholder with 750+ lines of comprehensive documentation)

### Learnings
- The game has significant strategic depth from trump selection timing, opt-in/opt-out mechanics, and card exchange
- Party player role carries both privilege (choosing trump) and risk (double penalties)
- Mandatory Ace of trump rule adds interesting tactical constraint
- Trump escalation rule (must play higher trump when trump is led) creates forced play scenarios
- Consecutive sit-out tracking (max 2 rounds) prevents passive play
- Clubs trump forces all players to play, creating high-participation rounds
- Prize calculation (€0.05 per remaining point) provides clear monetary incentive
- Score table UI should use visual indicators (bold for dealer, underline for party player, colors for point changes)
- Edge cases around trump Ace + following suit need clear documentation
- Negative points are valid and common near game end

### Next steps
- Issue #16: Design database schema and domain models (now have complete rules to inform entity design)
- Issue #11: Define REST API and gRPC contracts (rules documentation will guide endpoint design)
- Issue #15: Create UI/UX wireframes and mockups (rules documentation includes score table requirements)

## 2026-02-02 - Issue #16: Design database schema and domain models

### What was implemented
- Created comprehensive database schema documentation in docs/database-schema.md (25KB+)
- Designed complete Entity Relationship Diagram (ERD) with 7 core entities
- Implemented all domain models in SobeSobe.Core project with EF Core annotations
- Created enums: GameStatus, RoundStatus, TrumpSuit, ScoreReason
- Created Card value object with validation and rank value methods
- Created 7 entity classes: User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory
- Documented all relationships and foreign keys (1:N, with CASCADE/RESTRICT rules)
- Defined comprehensive data validation rules for all entities
- Designed performance indexes for common query patterns
- Planned data archival strategy (90-day archival for completed games)
- Documented migration strategy from SQLite → Azure SQL Database

**Entity Highlights:**
- User: Authentication, profile, cumulative statistics (games played, wins, prize won)
- Game: Game instance lifecycle (Waiting → InProgress → Completed/Abandoned)
- Round: Round lifecycle with dealer/party player tracking, trump selection, trick value
- PlayerSession: Player participation with position, points, consecutive rounds out tracking
- Hand: JSON storage for current and initial cards (5-card hands)
- Trick: JSON storage for cards played in order, lead and winner tracking
- ScoreHistory: Complete audit trail of all point changes with reasons

**Key Design Decisions:**
- JSON storage for cards (flexible, easy to query)
- Normalized 3NF design with minimal redundancy
- Composite indexes for common patterns (GameId + RoundNumber, GameId + Position)
- ScoreHistory provides complete audit trail (GameStart, TricksWon, Penalties)
- Archival strategy keeps database performant (90-day moving window)
- Clear migration path from SQLite → SQL Server for production

### Files changed
- Created: docs/database-schema.md (comprehensive schema documentation)
- Created: backend/SobeSobe.Core/Enums/ (GameStatus, RoundStatus, TrumpSuit, ScoreReason)
- Created: backend/SobeSobe.Core/ValueObjects/Card.cs (card value object)
- Created: backend/SobeSobe.Core/Entities/ (User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory)
- Deleted: backend/SobeSobe.Core/Class1.cs (placeholder file)

### Learnings
- JSON columns in SQLite stored as TEXT, with System.Text.Json for serialization
- EF Core [NotMapped] attribute allows helper properties (e.g., Cards list from CardsJson)
- Foreign keys use required/nullable Guid to enforce relationships
- Composite indexes support queries like "find all rounds for game ordered by round number"
- ScoreHistory pattern provides complete audit trail and enables "undo" scenarios
- Archival strategy critical for long-term performance (millions of completed games)
- SQLite → SQL Server migration requires testing JSON functions and DateTime handling
- Card value object uses record type for value semantics and immutability
- Navigation properties use ICollection<T> for lazy loading support
- Range attributes on enums (0-4 for Position) prevent invalid data

### Next steps
- Issue #11: Define REST API and gRPC contracts (now have complete entity models)
- Create ApplicationDbContext and EF Core migrations
- Implement repository interfaces and patterns
- Add integration tests for entity validation rules

## 2026-02-02 - Issue #11: Define REST API and gRPC contracts

### What was implemented
- Created comprehensive API specification documentation in docs/api-specification.md (60KB+)
- Documented complete REST API with OpenAPI-style specification covering authentication, game management, and gameplay endpoints
- Created gRPC service definition file (backend/SobeSobe.Api/Protos/game-events.proto) for real-time bidirectional communication
- Defined 5 authentication endpoints (register, login, refresh, logout, get user)
- Defined 3 user management endpoints (get profile, update profile, get statistics)
- Defined 7 game lobby endpoints (list games, create, get details, join, leave, cancel, start)
- Defined 5 game action endpoints (get state, select trump, play decision, exchange cards, play card, get scores)
- Created gRPC service with 3 RPC methods (Subscribe, SendAction, Heartbeat) and 13 event types
- Documented 25+ error codes with detailed error response standards
- Defined comprehensive validation rules for all game actions aligned with game rules
- Included detailed request/response examples for all endpoints
- Documented error response format with contextual details for debugging

**API Architecture:**
- REST API for stateless operations (authentication, game management, query operations)
- gRPC for real-time bidirectional events (card plays, trick completion, score updates, game state changes)
- OAuth 2.0 / OpenID Connect with JWT Bearer tokens (15-min access, 7-day refresh)
- Consistent error response format with error codes, messages, details, and timestamps
- API versioning with /api/v1 prefix

**gRPC Events:**
- PlayerJoined/Left, GameStarted, RoundStarted
- TrumpSelected, CardDealt, PlayDecision, CardsExchanged
- CardPlayed, TrickCompleted, RoundCompleted, GameCompleted
- PlayerTurn (with action_required and timeout), Error events

**Validation Highlights:**
- Trump selection: Only party player, Hearts-only before dealing (4-point tricks), Clubs forces all players
- Player decisions: Max 2 consecutive sit-outs, party/dealer cannot opt out
- Card exchange: 0-3 cards, cannot exchange Ace of trump
- Trick-taking: Follow suit, trump escalation, mandatory Ace of trump rules
- Scoring: Tricks reduce points, zero-trick penalties (5/10/20 points), party player double penalty

### Files changed
- Modified: docs/api-specification.md (replaced placeholder with 60KB+ comprehensive API documentation)
- Created: backend/SobeSobe.Api/Protos/game-events.proto (gRPC service definition with 240+ lines)

### Learnings
- REST API ideal for stateless operations (create game, join, query state), gRPC for real-time push notifications
- Error responses should include contextual details (e.g., cards in hand that satisfy rule for "must follow suit" errors)
- JWT short-lived access tokens (15 min) + long-lived refresh tokens (7 days) balance security and UX
- gRPC oneof payload pattern allows single GameEvent message with polymorphic payloads for different event types
- Validation rules must enforce game rules (trump escalation, Ace of trump, follow suit) at API boundary
- API versioning (/api/v1) allows future breaking changes without disrupting existing clients
- Protobuf map<string, string> for error details provides flexibility for different error scenarios
- Heartbeat RPC keeps long-lived gRPC connections alive and detects disconnections
- Card exchange endpoint returns full updated hand to avoid client-side state synchronization bugs
- GET /games endpoint needs pagination to handle potentially large game lists

### Next steps
- Issue #14: Configure GitHub Actions for CI/CD (setup automated build/test/deploy)
- Issue #15: Create UI/UX wireframes and mockups (now have complete API contracts to inform frontend design)
- Implement REST endpoints in SobeSobe.Api with ASP.NET Core Minimal API
- Implement gRPC service in SobeSobe.Api with Grpc.AspNetCore
- Create DTO classes for request/response models
- Implement JWT authentication with ASP.NET Core Identity

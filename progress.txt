## 2026-02-03 - Issue #6: Real-time Communication - gRPC Event Broadcasting Integration

### What was implemented
- Integrated gRPC event broadcasting into all game action REST endpoints
- Added `using SobeSobe.Api.Extensions` to import GameEventExtensions
- Broadcast PlayerJoined event when player joins game
- Broadcast PlayerLeft event when player leaves game (only if game not deleted)
- Broadcast GameStarted event with all player info when game starts
- Broadcast TrumpSelected event when party player selects trump
- Broadcast CardPlayed event every time a card is played
- Broadcast TrickCompleted event when trick finishes (all players have played)
- Broadcast RoundCompleted event with score changes when round finishes (5 tricks)
- Broadcast GameCompleted event with final scores when game ends (player reaches ≤0 points)
- Updated start game endpoint to load PlayerSessions with User navigation property (ThenInclude)
- All event broadcasts use correct method signatures from GameEventExtensions
- Card positions used instead of UserIds for CardPlayed/TrickCompleted events
- Prize calculation added to GameCompleted event (€0.05 per remaining point from 20)

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added gRPC event broadcasting to 5 game endpoints)

### Learnings
- Event broadcasting must happen AFTER SaveChangesAsync to ensure data consistency
- GameStarted event requires full player list with positions and starting points
- CardPlayed events use position (0-4) not userId for player identification
- TrickCompleted needs to map PlayerSessionId to Position for cards played
- RoundCompleted scores need IsPenalty and IsPartyPlayer flags from scoreResponses
- GameCompleted calculates prize won: Math.Max(0, 20 - finalPoints) * 0.05
- PlayerLeft event only broadcast if game still exists (not deleted when last player leaves)
- Event signatures use tuples with named parameters for clarity
- Build succeeded after fixing all method signatures to match GameEventExtensions
- Real-time events now flow from REST API → gRPC service → all subscribed clients

### Next steps
- Test complete game flow with gRPC client subscribed (verify events received)
- Consider adding RoundStarted event broadcast when new round begins
- Add integration tests for event broadcasting
- Document event flow in docs/grpc-realtime-events.md
- Test with multiple concurrent clients to verify event fanout

## 2026-02-02 - Issue #1: Backend Development - Score History Endpoint Implementation

### What was implemented
- Implemented GET /api/games/{id}/scores endpoint for retrieving complete score history
- Created ScoreHistoryResponse and ScoreEntry DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Only players who have joined the game can view score history (403 Forbidden for non-players)
- Returns all score entries for the game ordered chronologically
- Includes comprehensive score details:
  - Player information (position, username, display name)
  - Round information (round ID, round number)
  - Points change (can be negative for penalties)
  - Points after change
  - Reason (GameStart, TricksWon, NoTricksNormalPenalty, NoTricksPartyPenalty)
  - Timestamp
- Eager loads PlayerSession with User and Round for efficient querying
- Handles nullable Round (for GameStart entries which don't have a round)
- Error handling: 401 Unauthorized, 404 Not Found (user/game), 403 Forbidden (not a player)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/ScoreHistoryResponse.cs (score history and score entry DTOs)
- Modified: backend/SobeSobe.Api/Program.cs (added GET /api/games/{id}/scores endpoint)

### Learnings
- Score history provides complete audit trail of all point changes throughout the game
- ScoreReason enum distinguishes between different types of score changes (tricks won vs penalties)
- Nullable Round field handles GameStart entries which initialize player points before first round
- EF Core Include() with ThenInclude() loads nested navigation properties efficiently
- Null-forgiving operators (!) needed for navigation properties loaded with Include/ThenInclude
- Chronological ordering by CreatedAt timestamp ensures scores displayed in correct sequence
- PlayerSession.User navigation property is nullable in entity, but guaranteed non-null when loaded with Include
- Score history endpoint critical for frontend to display detailed scoring breakdown and game progression
- Testing workflow: register → login → create → join → start → play round → get scores → verify all entries

### Next steps
- Implement real-time notifications for game events (gRPC/SignalR) - player joined, card played, trick completed
- Consider implementing endpoint to start new round after previous round completes
- Add unit tests for all game endpoints (registration through score history)
- Add integration tests for complete game flow
- Test complete game with multiple rounds to verify score accumulation

## 2026-02-02 - Issue #1: Backend Development - Get Game State Endpoint Implementation

### What was implemented
- Implemented GET /api/games/{id}/state endpoint for retrieving comprehensive game state
- Created GameStateResponse, PlayerStateResponse, RoundStateResponse, TrickStateResponse, and CardPlayedResponse DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Returns complete game state including:
  - Game metadata (status, players, dealer, round number)
  - All player information (position, points, consecutive rounds out, join/leave timestamps)
  - Current round details (trump suit, trick value, dealer, party player, status)
  - All tricks in current round (cards played, lead player, winner)
  - Current incomplete trick (if any)
  - Requesting player's hand (only their own cards are visible)
- Only players who have joined the game can view game state (403 Forbidden for non-players)
- Eager loads all related entities: CreatedBy, PlayerSessions with Users, current Round with Tricks and Hands
- Deserializes JSON data for cards played in tricks and player hands
- Orders players by position and tricks by trick number for consistent display
- Returns null for CurrentRound if game is not InProgress or has no rounds yet
- Error handling: 401 Unauthorized, 404 Not Found (user/game), 403 Forbidden (not a player)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/GameStateResponse.cs (comprehensive DTOs for game state, player state, round state, trick state, card played)
- Modified: backend/SobeSobe.Api/Program.cs (added GET /api/games/{id}/state endpoint)

### Learnings
- Game state endpoint critical for frontend to display current game and allow players to take actions
- Only requesting player's hand is populated (other players' hands remain null for privacy)
- EF Core Include() with ThenInclude() loads nested navigation properties in a single query
- SQLite's limitation with APPLY requires careful query construction for ordering and taking top records
- JsonSerializer.Deserialize<List<Card>>() and JsonSerializer.Deserialize<List<CardPlayedResponse>>() handle JSON columns
- Results.Json() with statusCode parameter allows returning custom status codes (403) with JSON body
- Required modifier on Card property in CardPlayedResponse ensures non-null cards
- Game state includes both completed and incomplete tricks to show full round history
- CurrentTrick identified by null CompletedAt timestamp
- Testing workflow: register → login → create → join → start → select trump → deal → get state → verify all data present

### Next steps
- Implement score history endpoint (GET /api/games/{id}/scores) - complete score audit trail
- Add real-time notifications for game events (gRPC/SignalR) - player joined, card played, trick completed
- Consider implementing endpoint to start new round after previous round completes
- Test complete game flow with state endpoint to ensure UI can display all game phases

## 2026-02-02 - Issue #1: Backend Development - Card Exchange Implementation

### What was implemented
- Implemented POST /api/games/{id}/rounds/current/exchange-cards endpoint for card exchange phase
- Created ExchangeCardsRequest and ExchangeCardsResponse DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Players can exchange 0-3 cards from their hand
- Validates all exchange rules from game rules documentation:
  - Cannot exchange more than 3 cards (400 Bad Request)
  - Cannot exchange Ace of trump (400 Bad Request with specific message)
  - Cannot exchange cards not in player's hand (400 Bad Request)
  - Must be in CardExchange phase (409 Conflict if wrong phase)
- Exchange mechanism:
  - Removes specified cards from player's hand
  - Creates new deck excluding all cards currently in play (all players' hands)
  - Shuffles remaining deck and draws replacement cards
  - Updates Hand entity with new cards JSON
- Returns full updated hand after exchange
- Error handling: 401 Unauthorized, 404 Not Found (game/round/player/hand), 400 Bad Request (validation), 409 Conflict (wrong phase)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/ExchangeCardsRequest.cs (list of cards to exchange, max 3)
- Created: backend/SobeSobe.Api/DTOs/ExchangeCardsResponse.cs (round ID, player session ID, cards exchanged count, new hand)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/rounds/current/exchange-cards endpoint, fixed SQLite APPLY query issue)

### Learnings
- SQLite doesn't support SQL APPLY operation used in `Include(g => g.Rounds.OrderByDescending(...).Take(1))`
- Fixed by splitting query: load Game first, then load current Round separately with explicit OrderByDescending
- Card exchange must exclude all cards in play (all players' hands) to prevent duplicates
- System.Text.Json.JsonSerializer used consistently for card serialization
- Exchange logic validates cards exist before removal to prevent corrupting hand state
- Empty exchange (0 cards) returns current hand without modification (valid use case)
- Ace of trump check uses round.TrumpSuit.ToString() to compare with card.Suit string
- CardDealingService.CreateDeck() and ShuffleDeck() reused for drawing replacement cards
- Testing workflow: register → login → create → join → start → select trump → deal → exchange (0-3 cards)
- All edge cases tested successfully: >3 cards (400), Ace of trump (400), card not in hand (400), valid exchange (200)

### Next steps
- Implement play card endpoint (POST /api/games/{id}/rounds/current/play-card) - trick-taking mechanics with follow suit and trump rules
- Implement get game state endpoint (GET /api/games/{id}/state) - full game state for UI
- Implement score history endpoint (GET /api/games/{id}/scores)
- Add real-time notifications for game events (gRPC/SignalR)
- Consider transitioning round from CardExchange to Playing phase automatically when all players have exchanged

## 2026-02-02 - Issue #1: Backend Development - Card Dealing Implementation

### What was implemented
- Created CardDealingService with deck creation, shuffling (Fisher-Yates algorithm), and counter-clockwise dealing logic
- Implemented POST /api/games/{id}/rounds/current/deal-cards endpoint for automatic card dealing
- Endpoint handles two dealing scenarios based on round status:
  - **Dealing phase** (trump selected before dealing): Deals 5 cards to all active players, moves to CardExchange
  - **PlayerDecisions phase** (trump selected after 2 cards): Deals 3 additional cards to players with Hands, moves to CardExchange
- Card dealing follows counter-clockwise order starting from party player
- Deck creation: 40 cards (Ace, 7, King, Queen, Jack, 6, 5, 4, 3, 2 in each of 4 suits)
- Shuffle uses Fisher-Yates algorithm for unbiased randomization
- Creates/updates Hand entities with serialized card JSON (CardsJson and InitialCardsJson)
- Validates round phase before dealing (409 Conflict if wrong phase)
- Error handling: 401 Unauthorized, 404 Not Found, 400 Bad Request (no active players), 409 Conflict (wrong phase)

### Files changed
- Created: backend/SobeSobe.Api/Services/CardDealingService.cs (deck creation, shuffling, dealing logic)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/rounds/current/deal-cards endpoint, imported System.Text.Json and SobeSobe.Core.ValueObjects)

### Learnings
- Fisher-Yates shuffle algorithm provides O(n) unbiased card randomization
- Counter-clockwise dealing order: party player (dealer + 1) receives cards first
- GetCounterClockwiseOrder handles non-sequential player positions correctly
- Hand.CardsJson stores current cards, InitialCardsJson stores original dealt cards for audit
- System.Text.Json.JsonSerializer used for Card list serialization/deserialization
- Dealing in "Dealing" phase creates new Hands, dealing in "PlayerDecisions" phase updates existing Hands
- Round.Status automatically transitions to CardExchange after dealing completes
- Null-forgiving operator (!) needed for navigation properties loaded with Include() to suppress compiler warnings
- Testing workflow path 1: start → select trump (blind) → deal (5 cards) → CardExchange
- Testing workflow path 2: start → select trump (after cards) → player decisions → deal (3 cards) → CardExchange
- Both dealing paths tested successfully: blind trump (5 cards) and after-decisions (3 cards)

### Next steps
- Implement card exchange endpoint (POST /api/games/{id}/rounds/current/exchange-cards) - 0-3 cards
- Implement play card endpoint (POST /api/games/{id}/rounds/current/play-card) - trick-taking mechanics
- Implement get game state endpoint (GET /api/games/{id}/state) - full game state for UI
- Implement score history endpoint (GET /api/games/{id}/scores)
- Add real-time notifications for game events (gRPC/SignalR)
- Consider implementing initial 2-card deal for "after cards" trump selection (currently skipped)

## 2026-02-02 - Issue #1: Backend Development - Player Decision Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/rounds/current/play-decision endpoint for opt-in/opt-out decisions
- Created PlayDecisionRequest and PlayDecisionResponse DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Validates player is in the game and round is in PlayerDecisions phase
- Implements all game rule validations:
  - Party player must always play (cannot opt out)
  - Dealer must always play (cannot opt out)
  - Clubs trump forces all players to play
  - Cannot sit out more than 2 consecutive rounds
  - Players with 5 points or less must play
- Tracks consecutive rounds out counter:
  - Increments when player opts out
  - Resets to 0 when player opts in
- Creates Hand entity for players who opt in (cards dealt later)
- Removes Hand entity for players who opt out
- Returns decision result with roundId, playerSessionId, willPlay, consecutiveRoundsOut
- Error handling: 401 Unauthorized, 404 Not Found, 400 Bad Request (validation failures), 409 Conflict (wrong phase)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/PlayDecisionRequest.cs (willPlay boolean)
- Created: backend/SobeSobe.Api/DTOs/PlayDecisionResponse.cs (decision result with consecutive rounds out)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/rounds/current/play-decision endpoint after trump selection)

### Learnings
- Player decisions tracked via Hand entities (presence = playing, absence = sitting out)
- ConsecutiveRoundsOut property in PlayerSession enforces max 2 consecutive sit-outs
- Party player and dealer have automatic opt-in (validated server-side)
- Clubs trump is special forcing rule that requires all players to participate
- Low points threshold (≤5 points) forces players to play
- Hand creation happens during decision phase with empty cards array (populated during dealing)
- Phase validation ensures decisions only made during PlayerDecisions phase
- Testing workflow: register (3 users) → login → create game → join → start → select trump → make decisions
- Tested edge cases: party player opt-out (400), dealer opt-out (400), Clubs trump opt-out (400), valid opt-in/opt-out
- Counter increments only on opt-out, resets on opt-in for flexible player strategies

### Next steps
- Implement card dealing logic (deal 2 cards initially after trump, 3 more after decisions)
- Implement card exchange endpoint (POST /api/games/{id}/rounds/current/exchange-cards) - 0-3 cards
- Implement play card endpoint (POST /api/games/{id}/rounds/current/play-card) - trick-taking mechanics
- Implement get game state endpoint (GET /api/games/{id}/state) - full game state for UI
- Implement score history endpoint (GET /api/games/{id}/scores)
- Add real-time notifications for game events (gRPC/SignalR)

## 2026-02-02 - Issue #1: Backend Development - Trump Selection Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/rounds/current/trump endpoint for selecting trump suit
- Created SelectTrumpRequest and SelectTrumpResponse DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Only allows party player to select trump (returns 403 Forbidden for others)
- Validates game exists and round is in TrumpSelection phase (returns 409 Conflict if wrong phase)
- Validates trump selection rules:
  - Only Hearts can be selected before dealing (selectedBeforeDealing = true)
  - Any suit can be selected after receiving 2 cards (selectedBeforeDealing = false)
- Calculates trick value based on trump suit and timing:
  - Hearts before dealing: 4 points (blind trump)
  - Hearts after 2 cards: 2 points
  - Diamonds/Clubs/Spades before dealing: 2 points
  - Diamonds/Clubs/Spades after 2 cards: 1 point
- Updates round with trump selection and moves to next phase:
  - If selected before dealing: moves to Dealing phase
  - If selected after 2 cards: moves to PlayerDecisions phase
- Returns trump details including roundId, trumpSuit, trumpSelectedBeforeDealing, trickValue
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found), 403 Forbidden (not party player), 400 Bad Request (invalid trump rules), 409 Conflict (wrong phase)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/SelectTrumpRequest.cs (trump suit and timing input)
- Created: backend/SobeSobe.Api/DTOs/SelectTrumpResponse.cs (trump selection result)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/rounds/current/trump endpoint after start game endpoint)

### Learnings
- Trump selection has complex rules based on timing (before/after dealing) and suit
- Hearts before dealing (blind trump) doubles trick values from 2→4 (Hearts) or 1→2 (others)
- Party player is determined when game starts based on dealer position (counter-clockwise)
- Round.Status progression: TrumpSelection → Dealing (if blind) or PlayerDecisions (if after cards)
- EF Core Include() with OrderByDescending().Take(1) efficiently loads most recent round
- Switch expressions provide clean syntax for trick value calculation based on suit
- RoundStatus enum: TrumpSelection (1) → Dealing (0) or PlayerDecisions (2)
- Testing workflow: register → login (2 users) → create game → join game → start game → select trump (party player only)
- Tested edge cases: Hearts before dealing (4 pts), Diamonds after dealing (1 pt), invalid suit before dealing (400), selecting twice (409)
- Phase validation prevents trump selection at wrong time (already selected or game not started)

### Next steps
- Implement player decision endpoint (POST /api/games/{id}/rounds/current/play-decision) - opt-in/opt-out
- Implement card dealing logic (deal 2 cards initially, then 3 more after decisions)
- Implement card exchange endpoint (POST /api/games/{id}/rounds/current/exchange-cards)
- Implement play card endpoint (POST /api/games/{id}/rounds/current/play-card)
- Implement get game state endpoint (GET /api/games/{id}/state)
- Implement score history endpoint (GET /api/games/{id}/scores)
- Add real-time notifications for game events (gRPC/SignalR)

## 2026-02-02 - Issue #1: Backend Development - Cancel Game Endpoint Implementation

### What was implemented
- Implemented DELETE /api/games/{id} endpoint for canceling games before they start
- Endpoint requires authentication (.RequireAuthorization())
- Only allows game creator to cancel (returns 403 Forbidden for non-creators)
- Validates game exists and is in Waiting status (cannot cancel started games)
- Deletes the entire game including all player sessions (cascading delete)
- Returns 200 OK with success message on successful cancellation
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found), 403 Forbidden (not creator), 400 Bad Request (game already started)

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added DELETE /api/games/{id} endpoint after leave game endpoint)

### Learnings
- Results.StatusCode(403) returns 403 Forbidden status code for authorization failures
- EF Core Remove() on Game entity triggers cascading delete for related PlayerSessions
- DELETE HTTP method follows RESTful conventions for resource deletion
- Authorization checks: authentication (valid token) + ownership (creator only)
- Game status validation prevents canceling in-progress games
- Cascading delete configured in ApplicationDbContext removes child entities automatically
- Minimal API .WithName() provides friendly name for OpenAPI documentation
- Testing workflow: register → login (2 users) → create game (user 1) → join game (user 2) → try cancel as user 2 (403) → cancel as user 1 (200) → verify game deleted (404)

### Next steps
- Implement start game endpoint (POST /api/games/{id}/start) - transitions game to InProgress
- Implement game action endpoints (trump selection, play decision, card exchange, play card)
- Implement game state endpoint (GET /api/games/{id}/state)
- Implement score history endpoint (GET /api/games/{id}/scores)
- Add real-time notifications for game events (gRPC/SignalR)

## 2026-02-02 - Issue #1: Backend Development - Join Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/join endpoint for joining existing games
- Endpoint requires authentication (.RequireAuthorization())
- Validates game exists and is in Waiting status (cannot join started games)
- Checks if user is already in the game (returns 409 Conflict)
- Checks if game is full (returns 400 Bad Request)
- Automatically assigns next available position (0-4)
- Creates PlayerSession with 20 starting points for joining user
- Returns join response with gameId and full PlayerSession details
- Tested successfully: create game → join game → verify duplicate join (409) → verify full game (400)

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/join endpoint)

### Learnings
- Results.Conflict() returns 409 status code for duplicate resource operations
- HashSet<int> efficient for checking occupied positions in small collections
- EF Core Include() loads navigation properties needed for validation (PlayerSessions)
- Next available position algorithm: iterate 0-4 until finding unoccupied position
- Game status check prevents joining games that have already started
- PlayerSession created with same pattern as game creator (20 points, IsActive=true)
- JoinedAt timestamp tracks when each player joined the game
- Position assignment maintains seat order for game flow (dealer rotation)
- Error handling: 401 Unauthorized (no token), 404 Not Found (user/game), 409 Conflict (already joined), 400 Bad Request (game full or started)
- Testing workflow: register → login → create game (user 2) → join game (user 3) → verify game has 2 players → test duplicate join → test full game

### Next steps
- Implement leave game endpoint (POST /api/games/{id}/leave)
- Implement cancel game endpoint (DELETE /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management
- Add real-time notifications for game events (gRPC/SignalR)
## 2026-02-02 - Issue #1: Backend Development - Get Game Details Endpoint Implementation

### What was implemented
- Implemented GET /api/games/{id} endpoint for fetching full game details
- Endpoint accepts Guid game ID as route parameter
- Uses EF Core Include() to eagerly load CreatedBy user and PlayerSessions with User navigation properties
- Returns comprehensive GameResponse with full game state and player list
- Returns 404 Not Found if game doesn't exist
- Endpoint is public (no authentication required) to allow viewing game details
- Fixed null reference warnings in both list games and get game details endpoints by adding null-forgiving operators (!)
- Tested successfully: create game → fetch details → verify 404 for non-existent game

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added GET /api/games/{id} endpoint, fixed null reference warnings)

### Learnings
- Route parameter constraints with {id:guid} enforce Guid type in URL
- FirstOrDefaultAsync() with Include() eagerly loads navigation properties
- Null-forgiving operator (!) suppresses compiler warnings for navigation properties loaded with Include()
- EF Core Include() with ThenInclude() ensures nested navigation properties (Game → PlayerSessions → User) are loaded
- Minimal API results: Results.Ok() for 200, Results.NotFound() for 404
- Players ordered by Position property for consistent display order
- GameResponse DTO reused from create game endpoint for consistency
- Public endpoints allow browsing game state before joining (transparency for users)
- Testing workflow: register → login → create game → get game details → verify 404

### Next steps
- Implement join game endpoint (POST /api/games/{id}/join)
- Implement leave game endpoint (POST /api/games/{id}/leave)
- Implement cancel game endpoint (DELETE /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management

## 2026-02-02 - Issue #1: Backend Development - Create Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games endpoint for creating new games
- Created CreateGameRequest DTO (validates maxPlayers 2-5)
- Created GameResponse and PlayerSessionResponse DTOs
- Endpoint requires authentication (.RequireAuthorization())
- Creates Game entity with Waiting status and creator as first player
- Automatically creates PlayerSession for game creator at position 0 with 20 starting points
- Returns comprehensive GameResponse with game details and player list
- Tested successfully: register → login → create game workflow

### Files changed
- Created: backend/SobeSobe.Api/DTOs/CreateGameRequest.cs (maxPlayers validation)
- Created: backend/SobeSobe.Api/DTOs/GameResponse.cs (game and player session response DTOs)
- Modified: backend/SobeSobe.Api/Program.cs (added create game endpoint, imported SobeSobe.Core.Enums)

### Learnings
- Game entity uses CreatedByUserId property (not CreatedBy as initially attempted)
- Game entity uses CurrentDealerPosition property (not CurrentDealerIndex)
- GameStatus enum value 0 = Waiting (enum serialized as integer in JSON)
- Game creator automatically joins as first player at position 0
- PlayerSession tracks currentPoints (starts at 20), isActive, and consecutiveRoundsOut
- Response includes full player details with username, displayName, and avatarUrl from User entity
- JWT authentication extracts userId from "sub" claim and verifies user exists before creating game
- Returns 201 Created with Location header pointing to /api/games/{id}
- Comprehensive error handling: 401 if not authenticated, 404 if user not found

### Next steps
- Implement join game endpoint (POST /api/games/{id}/join)
- Implement list games endpoint (GET /api/games)
- Implement get game details endpoint (GET /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management

## 2026-02-02 - Issue #1: Backend Development - List Games Endpoint Implementation

### What was implemented
- Implemented GET /api/games endpoint for listing available games with pagination and filtering
- Created ListGamesResponse DTO with pagination metadata (page, pageSize, totalPages, totalItems)
- Created GameListItem, UserSummary, PlayerSummary DTOs for clean response structure
- Endpoint supports optional query parameters: status (filter by game status), createdBy (filter by creator), page (default 1), pageSize (default 20, max 100)
- Uses EF Core Include() to eagerly load CreatedBy user and PlayerSessions with User navigation properties
- Orders games by creation date (newest first) for consistent pagination
- Returns games with full player list (username, displayName, position) ordered by position
- Endpoint is public (no authentication required) to allow browsing available games
- Tested successfully: pagination (page 1/2 with pageSize 2), filtering (status=0), total count calculations

### Files changed
- Created: backend/SobeSobe.Api/DTOs/ListGamesResponse.cs (response DTOs for list games endpoint)
- Modified: backend/SobeSobe.Api/Program.cs (added GET /api/games endpoint before POST /api/games)

### Learnings
- EF Core Include() with ThenInclude() enables eager loading nested navigation properties (Game → PlayerSessions → User)
- Query filters applied before pagination for accurate total count and page count calculations
- Math.Ceiling() calculates total pages from total items and page size
- Skip() and Take() implement offset-based pagination in EF Core
- Validation: page < 1 defaults to 1, pageSize outside 1-100 range defaults to 20
- OrderByDescending(g => g.CreatedAt) ensures consistent ordering across pagination (newest games first)
- Public endpoint allows lobby browsing without authentication (join requires auth)
- PlayerSessions.Count gives current player count efficiently
- LINQ Select() projects Game entities to GameListItem DTOs with nested UserSummary and PlayerSummary objects
- OrderBy(ps => ps.Position) ensures players listed in seat order (0, 1, 2, 3, 4)
- Pagination metadata includes all information needed for UI pagination controls (current page, total pages, total items)

### Next steps
- Implement get game details endpoint (GET /api/games/{id})
- Implement join game endpoint (POST /api/games/{id}/join)
- Implement leave game endpoint (POST /api/games/{id}/leave)
- Implement cancel game endpoint (DELETE /api/games/{id})
- Implement start game endpoint (POST /api/games/{id}/start)
- Implement game state machine for round and trick management

## 2026-02-02 - Issue #1: Backend Development - Get Current User Endpoint Implementation

### What was implemented
- Implemented GET /api/auth/user endpoint requiring authentication
- Endpoint uses .RequireAuthorization() to enforce JWT Bearer token
- Extracts user ID from JWT "sub" claim
- Finds user in database and returns UserResponse DTO
- Returns 401 Unauthorized without valid JWT token
- Returns 404 Not Found if user doesn't exist
- Configured JWT authentication to disable inbound claim mapping (MapInboundClaims = false)
- Set NameClaimType and RoleClaimType for proper claim handling

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added get current user endpoint, updated JWT configuration)

### Learnings
- .RequireAuthorization() in Minimal API enforces authentication on endpoints
- MapInboundClaims = false prevents ASP.NET from converting JWT claim names (sub → NameIdentifier)
- JWT "sub" claim accessed via JwtRegisteredClaimNames.Sub
- HttpContext.User.FindFirst() retrieves claim from authenticated user
- NameClaimType = JwtRegisteredClaimNames.UniqueName sets default name claim
- Invoke-RestMethod with -Headers @{ "Authorization" = "Bearer $token" } sends JWT token
- Returns 401 if no token provided, 404 if user not found, 200 OK with user data if authenticated
- Test workflow: login → get user (with token) → get user (without token, should fail)

### Next steps
- Add background job to clean up expired refresh tokens periodically
- Implement remaining user management endpoints (get profile by ID, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)
- Implement game state machine for game lifecycle

## 2026-02-02 - Issue #1: Backend Development - Logout Endpoint Implementation

### What was implemented
- Implemented POST /api/auth/logout endpoint for logging out users
- Created LogoutRequest DTO
- Logout endpoint revokes refresh token by calling RevokeRefreshTokenAsync
- Returns 200 OK with success message
- Tested successfully: logout revokes refresh token, subsequent refresh attempts fail with 400 Bad Request

### Files changed
- Created: backend/SobeSobe.Api/DTOs/LogoutRequest.cs (refresh token input for logout)
- Modified: backend/SobeSobe.Api/Program.cs (added logout endpoint)

### Learnings
- Logout endpoint simple but critical for security
- Revoking refresh token prevents further token refresh attempts
- Client should discard access token locally on logout (access tokens can't be revoked server-side)
- Returns 200 OK even if refresh token not found (idempotent operation)
- Test workflow: login → logout → try refresh (should fail with 400)

### Next steps
- Implement get current user endpoint (GET /api/auth/user) with [Authorize] attribute
- Add background job to clean up expired refresh tokens
- Implement remaining user management endpoints (get profile, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)

## 2026-02-02 - Issue #1: Backend Development - Token Refresh Implementation

### What was implemented
- Implemented POST /api/auth/refresh endpoint for refreshing access tokens
- Created RefreshToken entity to store refresh tokens in database
- Created RefreshTokenRequest and RefreshTokenResponse DTOs
- Extended JwtTokenService with methods: GenerateAndStoreRefreshTokenAsync, ValidateRefreshTokenAsync, RevokeRefreshTokenAsync, RevokeAllUserRefreshTokensAsync
- Updated ApplicationDbContext to include RefreshTokens DbSet with indexes on Token (unique), UserId, and ExpiresAt
- Created EF Core migration "AddRefreshToken" to add RefreshTokens table
- Updated login endpoint to store refresh tokens in database
- Changed JwtTokenService from Singleton to Scoped lifetime (requires DbContext)
- Refresh tokens expire after 7 days, old refresh tokens automatically revoked on refresh
- Tested successfully: login generates stored refresh token, refresh endpoint returns new tokens, old refresh token properly revoked

### Files changed
- Created: backend/SobeSobe.Core/Entities/RefreshToken.cs (entity with UserId FK, Token, ExpiresAt, CreatedAt, RevokedAt, IsActive property)
- Created: backend/SobeSobe.Api/DTOs/RefreshTokenRequest.cs (refresh token input)
- Created: backend/SobeSobe.Api/DTOs/RefreshTokenResponse.cs (new access token and refresh token)
- Modified: backend/SobeSobe.Core/Entities/User.cs (added RefreshTokens navigation property)
- Modified: backend/SobeSobe.Infrastructure/Data/ApplicationDbContext.cs (added RefreshTokens DbSet, configured entity relationships)
- Modified: backend/SobeSobe.Api/Services/JwtTokenService.cs (added database storage and validation methods, constructor now requires ApplicationDbContext)
- Modified: backend/SobeSobe.Api/Program.cs (changed JwtTokenService to Scoped, updated login to use GenerateAndStoreRefreshTokenAsync, added refresh endpoint)
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/20260202133418_AddRefreshToken.cs (EF Core migration)

### Learnings
- Refresh tokens must be stored in database for revocation and security audit trail
- Service lifetime matters: JwtTokenService changed from Singleton to Scoped to access DbContext
- RefreshToken entity tracks creation time, expiration, and revocation with IsActive computed property
- Token revocation: old refresh token revoked immediately when new tokens issued
- EF Core Include() method loads User navigation property when validating refresh token
- Unique index on Token column prevents duplicate refresh tokens
- CASCADE delete on UserId FK ensures orphaned refresh tokens deleted when user deleted
- Test workflow: register → login (get tokens) → refresh (get new tokens) → try old token (should fail)
- 7-day refresh token expiry balances security and user experience
- FirstOrDefaultAsync with Token lookup efficient with unique index

### Next steps
- Implement logout endpoint (POST /api/auth/logout) with token revocation
- Implement get current user endpoint (GET /api/auth/user) with [Authorize] attribute
- Add background job to clean up expired refresh tokens periodically
- Implement remaining user management endpoints (get profile, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)

## 2026-02-02 - Issue #1: Backend Development - User Login with JWT Authentication

### What was implemented
- Implemented POST /api/auth/login endpoint with JWT token generation
- Created JwtTokenService for generating access tokens (15-min expiry) and refresh tokens
- Created LoginRequest and LoginResponse DTOs
- Configured JWT Bearer authentication in Program.cs with token validation
- Added JWT configuration to appsettings.json (secret, issuer, audience)
- Login endpoint accepts username OR email, verifies password, updates LastLoginAt timestamp
- Returns 200 OK with access token, refresh token, token type, expiry, and user data on success
- Returns 400 Bad Request on invalid credentials
- Tested successfully: login with username, login with email, invalid password handling

### Files changed
- Created: backend/SobeSobe.Api/Services/JwtTokenService.cs (JWT token generation using HS256, 15-min access token, secure refresh token)
- Created: backend/SobeSobe.Api/DTOs/LoginRequest.cs (username or email + password)
- Created: backend/SobeSobe.Api/DTOs/LoginResponse.cs (access token, refresh token, token type, expiry, user data)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added Microsoft.AspNetCore.Authentication.JwtBearer 10.0.2, System.IdentityModel.Tokens.Jwt 8.4.0)
- Modified: backend/SobeSobe.Api/appsettings.json (added JWT configuration: Secret, Issuer, Audience)
- Modified: backend/SobeSobe.Api/Program.cs (configured JWT authentication, added login endpoint)

### Learnings
- JwtSecurityTokenHandler.WriteToken() generates compact JWT token string
- SymmetricSecurityKey with HS256 algorithm for signing tokens (secret must be at least 32 bytes)
- JWT claims use JwtRegisteredClaimNames (Sub for user ID, UniqueName for username, Email, Jti for token ID)
- Access tokens short-lived (15 min), refresh tokens long-lived (simplified implementation, production should store in DB)
- Refresh token generated using RandomNumberGenerator.GetBytes() for crypto-secure randomness
- Login endpoint updates LastLoginAt timestamp for user activity tracking
- FirstOrDefaultAsync with OR condition searches username OR email in single query
- Authentication middleware must be called before Authorization: UseAuthentication() then UseAuthorization()
- JWT configuration in appsettings.json: Secret (min 32 chars), Issuer (API identifier), Audience (client identifier)
- Build succeeded, all tests pass, login endpoint tested successfully with username and email

### Next steps
- Implement token refresh endpoint (POST /api/auth/refresh)
- Implement logout endpoint (POST /api/auth/logout) with token revocation
- Implement get current user endpoint (GET /api/auth/user) with [Authorize] attribute
- Store refresh tokens in database for security and revocation
- Add claims-based authorization for protected endpoints
- Implement remaining user management endpoints (get profile, update profile, statistics)
- Start implementing game management endpoints (create game, join game, list games)

## 2026-02-02 - Issue #13: Initialize monorepo project structure

### What was implemented
- Created root repository directory structure (frontend/, backend/, infrastructure/, docs/, .github/workflows/)
- Initialized Angular 19+ project in /frontend with Tailwind CSS v3 support
- Initialized .NET 10 solution with multiple projects:
  - SobeSobe.Api (Minimal API)
  - SobeSobe.Core (Domain models and interfaces)
  - SobeSobe.Infrastructure (Data access layer)
  - SobeSobe.AppHost (Aspire orchestration)
  - SobeSobe.Tests (Test project)
- Created comprehensive documentation:
  - README.md with project overview and setup instructions
  - LICENSE (MIT)
  - CONTRIBUTING.md with development guidelines
  - docs/game-rules.md (placeholder)
  - docs/api-specification.md (placeholder)
  - docs/architecture.md (placeholder)
- Added comprehensive .gitignore for .NET, Angular, and tooling

### Files changed
- Created: .gitignore, README.md, LICENSE, CONTRIBUTING.md
- Created: frontend/ directory with Angular 19 app, Tailwind CSS v3, PostCSS config
- Created: backend/ directory with .NET 10 solution and 5 projects
- Created: docs/ directory with placeholder documentation files
- Created: infrastructure/, .github/workflows/ directories (empty, ready for next tasks)

### Learnings
- .NET Aspire templates are installed via `dotnet new install Aspire.ProjectTemplates` not workload
- Tailwind CSS v4 requires @tailwindcss/postcss plugin, but Angular build has compatibility issues - using v3 instead
- Angular 19 uses standalone components by default
- Frontend builds successfully, backend builds and tests pass

### Next steps
- Issue #9: Setup .NET Aspire for local development (AppHost is created, needs configuration)
- Issue #12: Write comprehensive game rules documentation
- Issue #11: Define REST API and gRPC contracts

## 2026-02-02 - Issue #9: Setup .NET Aspire for local development

### What was implemented
- Configured .NET Aspire AppHost to orchestrate the backend API service
- Created SobeSobe.ServiceDefaults project with telemetry, health checks, and service discovery
- Integrated Aspire ServiceDefaults into SobeSobe.Api for automatic health checks and observability
- Added `AddServiceDefaults()` and `MapDefaultEndpoints()` to API for health check endpoints
- Created comprehensive Aspire usage documentation (docs/aspire-usage.md)
- Aspire Dashboard provides real-time monitoring, logs, traces, and metrics
- Used Aspire 9.5.2 with .NET 10 SDK (no workload required, NuGet packages only)

### Files changed
- Modified: backend/SobeSobe.AppHost/AppHost.cs (configured API service orchestration)
- Modified: backend/SobeSobe.AppHost/SobeSobe.AppHost.csproj (added Aspire.Hosting.AppHost package)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added ServiceDefaults reference)
- Modified: backend/SobeSobe.Api/Program.cs (integrated Aspire service defaults)
- Created: backend/SobeSobe.ServiceDefaults/ (Aspire service defaults project)
- Modified: backend/SobeSobe.sln (added ServiceDefaults project)
- Created: docs/aspire-usage.md (comprehensive Aspire documentation)

### Learnings
- .NET Aspire 9.5.2 is the latest stable version compatible with .NET 10 SDK
- Aspire 13.x versions don't exist yet; documentation was referencing future versions
- Aspire.Hosting.Sqlite and Aspire.Hosting.NodeJs packages had version compatibility issues
- Removed `IsAspireHost` property to avoid deprecated workload detection in .NET 10
- Simplified AppHost by deferring SQLite integration until database schema is designed (Issue #16)
- Deferred Angular/Node.js integration in AppHost to future iteration
- Used `AddExecutable` as workaround for project reference metadata generation issues
- ServiceDefaults provides automatic health checks at `/health` and `/alive` endpoints
- Aspire Dashboard accessible at https://localhost:17032 or http://localhost:15283
- All builds and tests pass successfully

### Next steps
- Issue #16: Design database schema (will integrate SQLite with Aspire after schema is ready)
- Issue #12: Write comprehensive game rules documentation
- Issue #11: Define REST API and gRPC contracts
- Future: Integrate Angular frontend with AppHost using Aspire.Hosting.NodeJs

## 2026-02-02 - Issue #12: Write comprehensive game rules documentation

### What was implemented
- Created comprehensive game rules documentation in docs/game-rules.md with 750+ lines of detailed content
- Documented complete game setup: deck composition, card ranking, initial state
- Documented round phase: dealer selection, party player role, trump selection (before/after dealing), player decisions, card exchange
- Documented trick-taking phase: follow suit rules, trump escalation, mandatory Ace of trump rule, winning conditions
- Documented scoring phase: point reduction for tricks won, penalties for zero tricks, party player double penalties
- Added glossary of Portuguese terms (Manilha, Copas às escuras, Cortar, etc.)
- Created detailed game state transition diagram showing flow from game start to end
- Provided 3-player example game with 5 complete rounds demonstrating all mechanics
- Documented 10 edge cases and special scenarios with resolutions
- Defined comprehensive validation rules for trump selection, player decisions, card exchange, trick-taking, and scoring
- Added UI/UX requirements for score table visualization
- Included detailed examples and tables for trick values, penalties, and scoring calculations

### Files changed
- Modified: docs/game-rules.md (replaced placeholder with 750+ lines of comprehensive documentation)

### Learnings
- The game has significant strategic depth from trump selection timing, opt-in/opt-out mechanics, and card exchange
- Party player role carries both privilege (choosing trump) and risk (double penalties)
- Mandatory Ace of trump rule adds interesting tactical constraint
- Trump escalation rule (must play higher trump when trump is led) creates forced play scenarios
- Consecutive sit-out tracking (max 2 rounds) prevents passive play
- Clubs trump forces all players to play, creating high-participation rounds
- Prize calculation (€0.05 per remaining point) provides clear monetary incentive
- Score table UI should use visual indicators (bold for dealer, underline for party player, colors for point changes)
- Edge cases around trump Ace + following suit need clear documentation
- Negative points are valid and common near game end

### Next steps
- Issue #16: Design database schema and domain models (now have complete rules to inform entity design)
- Issue #11: Define REST API and gRPC contracts (rules documentation will guide endpoint design)
- Issue #15: Create UI/UX wireframes and mockups (rules documentation includes score table requirements)

## 2026-02-02 - Issue #16: Design database schema and domain models

### What was implemented
- Created comprehensive database schema documentation in docs/database-schema.md (25KB+)
- Designed complete Entity Relationship Diagram (ERD) with 7 core entities
- Implemented all domain models in SobeSobe.Core project with EF Core annotations
- Created enums: GameStatus, RoundStatus, TrumpSuit, ScoreReason
- Created Card value object with validation and rank value methods
- Created 7 entity classes: User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory
- Documented all relationships and foreign keys (1:N, with CASCADE/RESTRICT rules)
- Defined comprehensive data validation rules for all entities
- Designed performance indexes for common query patterns
- Planned data archival strategy (90-day archival for completed games)
- Documented migration strategy from SQLite → Azure SQL Database

**Entity Highlights:**
- User: Authentication, profile, cumulative statistics (games played, wins, prize won)
- Game: Game instance lifecycle (Waiting → InProgress → Completed/Abandoned)
- Round: Round lifecycle with dealer/party player tracking, trump selection, trick value
- PlayerSession: Player participation with position, points, consecutive rounds out tracking
- Hand: JSON storage for current and initial cards (5-card hands)
- Trick: JSON storage for cards played in order, lead and winner tracking
- ScoreHistory: Complete audit trail of all point changes with reasons

**Key Design Decisions:**
- JSON storage for cards (flexible, easy to query)
- Normalized 3NF design with minimal redundancy
- Composite indexes for common patterns (GameId + RoundNumber, GameId + Position)
- ScoreHistory provides complete audit trail (GameStart, TricksWon, Penalties)
- Archival strategy keeps database performant (90-day moving window)
- Clear migration path from SQLite → SQL Server for production

### Files changed
- Created: docs/database-schema.md (comprehensive schema documentation)
- Created: backend/SobeSobe.Core/Enums/ (GameStatus, RoundStatus, TrumpSuit, ScoreReason)
- Created: backend/SobeSobe.Core/ValueObjects/Card.cs (card value object)
- Created: backend/SobeSobe.Core/Entities/ (User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory)
- Deleted: backend/SobeSobe.Core/Class1.cs (placeholder file)

### Learnings
- JSON columns in SQLite stored as TEXT, with System.Text.Json for serialization
- EF Core [NotMapped] attribute allows helper properties (e.g., Cards list from CardsJson)
- Foreign keys use required/nullable Guid to enforce relationships
- Composite indexes support queries like "find all rounds for game ordered by round number"
- ScoreHistory pattern provides complete audit trail and enables "undo" scenarios
- Archival strategy critical for long-term performance (millions of completed games)
- SQLite → SQL Server migration requires testing JSON functions and DateTime handling
- Card value object uses record type for value semantics and immutability
- Navigation properties use ICollection<T> for lazy loading support
- Range attributes on enums (0-4 for Position) prevent invalid data

### Next steps
- Issue #11: Define REST API and gRPC contracts (now have complete entity models)
- Create ApplicationDbContext and EF Core migrations
- Implement repository interfaces and patterns
- Add integration tests for entity validation rules

## 2026-02-02 - Issue #11: Define REST API and gRPC contracts

### What was implemented
- Created comprehensive API specification documentation in docs/api-specification.md (60KB+)
- Documented complete REST API with OpenAPI-style specification covering authentication, game management, and gameplay endpoints
- Created gRPC service definition file (backend/SobeSobe.Api/Protos/game-events.proto) for real-time bidirectional communication
- Defined 5 authentication endpoints (register, login, refresh, logout, get user)
- Defined 3 user management endpoints (get profile, update profile, get statistics)
- Defined 7 game lobby endpoints (list games, create, get details, join, leave, cancel, start)
- Defined 5 game action endpoints (get state, select trump, play decision, exchange cards, play card, get scores)
- Created gRPC service with 3 RPC methods (Subscribe, SendAction, Heartbeat) and 13 event types
- Documented 25+ error codes with detailed error response standards
- Defined comprehensive validation rules for all game actions aligned with game rules
- Included detailed request/response examples for all endpoints
- Documented error response format with contextual details for debugging

**API Architecture:**
- REST API for stateless operations (authentication, game management, query operations)
- gRPC for real-time bidirectional events (card plays, trick completion, score updates, game state changes)
- OAuth 2.0 / OpenID Connect with JWT Bearer tokens (15-min access, 7-day refresh)
- Consistent error response format with error codes, messages, details, and timestamps
- API versioning with /api/v1 prefix

**gRPC Events:**
- PlayerJoined/Left, GameStarted, RoundStarted
- TrumpSelected, CardDealt, PlayDecision, CardsExchanged
- CardPlayed, TrickCompleted, RoundCompleted, GameCompleted
- PlayerTurn (with action_required and timeout), Error events

**Validation Highlights:**
- Trump selection: Only party player, Hearts-only before dealing (4-point tricks), Clubs forces all players
- Player decisions: Max 2 consecutive sit-outs, party/dealer cannot opt out
- Card exchange: 0-3 cards, cannot exchange Ace of trump
- Trick-taking: Follow suit, trump escalation, mandatory Ace of trump rules
- Scoring: Tricks reduce points, zero-trick penalties (5/10/20 points), party player double penalty

### Files changed
- Modified: docs/api-specification.md (replaced placeholder with 60KB+ comprehensive API documentation)
- Created: backend/SobeSobe.Api/Protos/game-events.proto (gRPC service definition with 240+ lines)

### Learnings
- REST API ideal for stateless operations (create game, join, query state), gRPC for real-time push notifications
- Error responses should include contextual details (e.g., cards in hand that satisfy rule for "must follow suit" errors)
- JWT short-lived access tokens (15 min) + long-lived refresh tokens (7 days) balance security and UX
- gRPC oneof payload pattern allows single GameEvent message with polymorphic payloads for different event types
- Validation rules must enforce game rules (trump escalation, Ace of trump, follow suit) at API boundary
- API versioning (/api/v1) allows future breaking changes without disrupting existing clients
- Protobuf map<string, string> for error details provides flexibility for different error scenarios
- Heartbeat RPC keeps long-lived gRPC connections alive and detects disconnections
- Card exchange endpoint returns full updated hand to avoid client-side state synchronization bugs
- GET /games endpoint needs pagination to handle potentially large game lists

### Next steps
- Issue #14: Configure GitHub Actions for CI/CD (setup automated build/test/deploy)
- Issue #15: Create UI/UX wireframes and mockups (now have complete API contracts to inform frontend design)
- Implement REST endpoints in SobeSobe.Api with ASP.NET Core Minimal API
- Implement gRPC service in SobeSobe.Api with Grpc.AspNetCore
- Create DTO classes for request/response models
- Implement JWT authentication with ASP.NET Core Identity

## 2026-02-02 - Issue #14: Configure GitHub Actions for CI/CD

### What was implemented
- Created comprehensive GitHub Actions CI/CD pipeline with 3 workflows
- **Frontend CI** (.github/workflows/frontend-ci.yml):
  - Runs on push/PR to main/develop when frontend code changes
  - Installs Node.js 20, runs ESLint, Prettier, builds Angular app
  - Executes unit tests with code coverage (Karma/Jasmine)
  - Uploads coverage to Codecov
  - Builds production bundle and uploads artifacts (7-day retention)
- **Backend CI** (.github/workflows/backend-ci.yml):
  - Runs on push/PR to main/develop when backend code changes
  - Sets up .NET 10 SDK, restores NuGet packages
  - Runs dotnet format check, builds solution in Release mode
  - Executes unit tests with XPlat Code Coverage
  - Uploads coverage to Codecov
  - Publishes API and uploads artifacts (7-day retention)
- **Deploy to Azure** (.github/workflows/deploy-azure.yml):
  - Runs on push to main or manual trigger
  - Builds frontend and backend independently
  - Deploys frontend to Azure Static Web Apps
  - Deploys backend to Azure App Service
  - Runs smoke tests for both frontend and backend health endpoints
- Updated rontend/package.json with 	est:ci and lint scripts
- Added CI/CD status badges to README.md
- Created comprehensive CI/CD documentation (docs/ci-cd.md) with:
  - Workflow descriptions, triggers, and requirements
  - GitHub secrets configuration guide
  - Branch protection rules recommendations
  - Code quality checks configuration
  - Troubleshooting guide for common CI/CD issues
  - Future enhancement roadmap

**CI/CD Architecture:**
- Path-based triggers: frontend and backend CI only run when respective code changes
- Artifact-based deployment: Build once, deploy multiple environments
- Smoke tests: Automated health checks after deployment
- Code coverage reporting: Integrated with Codecov for coverage tracking
- Branch protection: Enforces status checks before merging to main

### Files changed
- Created: .github/workflows/frontend-ci.yml (frontend build, lint, test pipeline)
- Created: .github/workflows/backend-ci.yml (backend build, test pipeline)
- Created: .github/workflows/deploy-azure.yml (Azure deployment pipeline)
- Modified: frontend/package.json (added test:ci and lint scripts)
- Modified: README.md (added CI/CD status badges)
- Created: docs/ci-cd.md (comprehensive CI/CD documentation)

### Learnings
- GitHub Actions path filters optimize CI runs by only triggering when relevant code changes
- Artifacts with 7-day retention provide debugging capability without long-term storage costs
- dotnet format with --verify-no-changes enforces consistent code style in CI
- Angular test:ci script needs --watch=false and --browsers=ChromeHeadless for CI environments
- Codecov action works with both frontend (lcov.info) and backend (coverage.cobertura.xml) formats
- Smoke tests should run after deployment to catch issues before users encounter them
- Branch protection rules prevent merging without passing status checks
- Azure Static Web Apps deployment uses API token, App Service uses service principal credentials
- continue-on-error: true allows workflows to report issues without blocking (ESLint, Prettier)
- Workflow artifacts enable manual testing and rollback scenarios

### Next steps
- Configure GitHub secrets (AZURE_STATIC_WEB_APPS_API_TOKEN, AZURE_CREDENTIALS, CODECOV_TOKEN)
- Enable branch protection rules on main branch
- Issue #10: Create Azure infrastructure with Bicep (provision Azure resources for deployment)
- Issue #15: Create UI/UX wireframes and mockups (design frontend user interfaces)
- Add integration tests to CI pipeline
- Configure Dependabot for automated security updates
- Add CodeQL security scanning

## 2026-02-02 - Issue #10: Create Azure infrastructure with Bicep

### What was implemented
- Created comprehensive Azure infrastructure as code using Bicep templates
- **Main orchestration file** (main.bicep): Orchestrates all resources at subscription scope
- **Module files**:
  - key-vault.bicep: Azure Key Vault for secrets with RBAC, soft delete, purge protection
  - app-service.bicep: App Service Plan + App Service for .NET 10 backend with managed identity
  - static-web-app.bicep: Azure Static Web Apps for Angular frontend with GitHub integration
  - monitoring.bicep: Log Analytics Workspace + Application Insights for observability
  - database.bicep: Azure SQL Server + Database (production only, dev/staging use SQLite)
- **Parameter files**: dev.parameters.json, staging.parameters.json, prod.parameters.json
- **Deployment script** (deploy.ps1): PowerShell script with validation, what-if, and deployment
- **Documentation** (infrastructure/README.md): Comprehensive guide with architecture, costs, troubleshooting

**Resource Configuration:**
- Dev: B1 App Service (~$13/mo), Free Static Web App, SQLite, ~$15-20/mo total
- Staging: B2 App Service (~$54/mo), Standard Static Web App, SQLite, ~$70-75/mo total
- Prod: P1v3 App Service (~$328/mo), Standard Static Web App, Azure SQL Basic, ~$355-365/mo total

**Security Features:**
- Managed identity for App Service → Key Vault access (no secrets in app settings)
- RBAC authorization on Key Vault (Key Vault Secrets User role)
- HTTPS enforcement, TLS 1.2 minimum, FTPS disabled
- Soft delete and purge protection on Key Vault
- Azure SQL accessible only from Azure services

**Deployment Features:**
- What-if mode for validation without creating resources
- Outputs saved to outputs/{env}-outputs.json for GitHub secrets configuration
- Unique resource naming using uniqueString() to avoid conflicts
- Environment-specific SKUs and retention policies
- Health check endpoints configured on App Service

### Files changed
- Created: infrastructure/main.bicep (main orchestration)
- Created: infrastructure/modules/key-vault.bicep
- Created: infrastructure/modules/app-service.bicep
- Created: infrastructure/modules/static-web-app.bicep
- Created: infrastructure/modules/monitoring.bicep
- Created: infrastructure/modules/database.bicep
- Created: infrastructure/parameters/dev.parameters.json
- Created: infrastructure/parameters/staging.parameters.json
- Created: infrastructure/parameters/prod.parameters.json
- Created: infrastructure/deploy.ps1 (deployment script)
- Created: infrastructure/README.md (comprehensive documentation)
- Created: infrastructure/outputs/.gitignore (ignore deployment outputs)
- Created: infrastructure/outputs/.gitkeep (track directory)

### Learnings
- Bicep targetScope 'subscription' allows creating resource groups in the same template
- Conditional modules (if environmentName == 'prod') generate BCP318 warnings but work correctly at deployment
- uniqueString(subscription().id, environmentName) ensures globally unique resource names
- System-assigned managed identity + RBAC is more secure than Key Vault access policies
- Static Web Apps Free tier sufficient for dev, Standard needed for custom domains (staging/prod)
- App Service linuxFxVersion 'DOTNETCORE|10.0' for .NET 10 runtime
- Azure SQL Basic tier (2GB) costs ~$5/mo, good starting point for production
- SQLite suitable for dev/staging, allows fast iteration without Azure costs
- Log Analytics workspace required for Application Insights (IngestionMode: 'LogAnalytics')
- deploy.ps1 script provides friendly UX with colored output, validation, what-if support

### Next steps
- Deploy infrastructure to Azure: `.\infrastructure\deploy.ps1 -Environment dev -WhatIf`
- Configure GitHub secrets from deployment outputs (see docs/ci-cd.md)
- Issue #15: Create UI/UX wireframes and mockups (design frontend user interfaces)
- Implement Entity Framework Core DbContext and migrations (Issue #3)
- Implement REST API endpoints and gRPC services (Issue #1)

## 2026-02-02 - Issue #3: Database and Persistence - Initial EF Core Setup

### What was implemented
- Created ApplicationDbContext with DbSet properties for all 7 entities (User, Game, Round, PlayerSession, Hand, Trick, ScoreHistory)
- Configured entity relationships with OnModelCreating: defined foreign keys, navigation properties, and cascade behaviors
- Added EF Core packages: Microsoft.EntityFrameworkCore.Sqlite (10.0.2) and Microsoft.EntityFrameworkCore.Design (10.0.2)
- Configured DbContext in SobeSobe.Api with SQLite connection string (Data Source=sobesobe.db)
- Created initial EF Core migration '20260202132251_InitialCreate' with all tables, indexes, and constraints
- Applied migration successfully - database created with 7 tables and 19 indexes
- Verified all builds and tests pass

### Files changed
- Created: backend/SobeSobe.Infrastructure/Data/ApplicationDbContext.cs (198 lines, complete DbContext with entity configurations)
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/20260202132251_InitialCreate.cs (EF Core migration)
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/20260202132251_InitialCreate.Designer.cs
- Created: backend/SobeSobe.Infrastructure/Data/Migrations/ApplicationDbContextModelSnapshot.cs
- Modified: backend/SobeSobe.Infrastructure/SobeSobe.Infrastructure.csproj (added EF Core packages and Core project reference)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added Microsoft.EntityFrameworkCore.Design package)
- Modified: backend/SobeSobe.Api/Program.cs (registered ApplicationDbContext with dependency injection)
- Modified: backend/SobeSobe.Api/appsettings.json (added DefaultConnection connection string)
- Deleted: backend/SobeSobe.Infrastructure/Class1.cs (placeholder file)
- Created: backend/SobeSobe.Api/sobesobe.db (SQLite database file, 176KB)

### Learnings
- EF Core 10.0.2 is the latest version compatible with .NET 10 SDK
- DbContext registration in Program.cs uses builder.Services.AddDbContext<ApplicationDbContext>() with UseSqlite()
- Entity navigation property names must match exactly in DbContext configuration (e.g., CreatedGames vs GamesCreated)
- JSON columns in SQLite use HasColumnName() to map JSON properties (CardsJson → ""Cards"" column)
- entity.Ignore() used for computed/unmapped properties (Cards list from CardsJson)
- Composite indexes created with HasIndex(e => new { e.Property1, e.Property2 })
- Unique constraints enforced with IsUnique() on indexes
- CASCADE delete for child entities (PlayerSessions, Hands, Tricks, ScoreHistory)
- RESTRICT delete for reference entities (User references from Round dealer/party player)
- SQLite WAL mode enabled automatically by EF Core for better concurrency
- Migration created from Infrastructure project with --output-dir Data/Migrations
- Database update applies all pending migrations and creates __EFMigrationsHistory table
- All 19 indexes created successfully for optimizing common query patterns

### Next steps
- Implement repository interfaces and patterns in SobeSobe.Infrastructure
- Create unit tests for ApplicationDbContext and entity validation
- Implement game logic service layer in SobeSobe.Core
- Start implementing REST API endpoints for authentication and game management (Issue #1)
- Integrate ApplicationDbContext with Aspire orchestration for dev workflow

## 2026-02-02 - Issue #1: Backend Development - User Registration Tracer Bullet

### What was implemented
- Created DTOs: RegisterUserRequest and UserResponse for API contracts
- Implemented PasswordHasher service using PBKDF2 with SHA256 (100,000 iterations, 16-byte salt, 32-byte hash)
- Created POST /api/users/register endpoint with full validation
- Endpoint validates username uniqueness, email uniqueness, and password strength
- Returns 201 Created with user data on success, 400 Bad Request on validation errors
- Tested endpoint manually - registration works, duplicate username/email validation works

### Files changed
- Created: backend/SobeSobe.Api/DTOs/RegisterUserRequest.cs (validation attributes for username, email, password, displayName)
- Created: backend/SobeSobe.Api/DTOs/UserResponse.cs (user data without password hash)
- Created: backend/SobeSobe.Api/Services/PasswordHasher.cs (PBKDF2 password hashing and verification)
- Modified: backend/SobeSobe.Api/Program.cs (added user registration endpoint, removed weather forecast placeholder)

### Learnings
- Minimal API endpoints use dependency injection - ApplicationDbContext injected directly into endpoint lambda
- Results.Created() returns 201 with Location header pointing to new resource
- Results.BadRequest() returns 400 with error message in response body
- PasswordHasher.HashPassword() generates 64-byte base64 string (16-byte salt + 32-byte hash)
- EF Core Any() method efficient for checking existence without loading full entity
- DTOs keep API contracts separate from domain models
- required keyword on DTO properties enforces non-null values
- RegularExpression validation attribute enforces username format (alphanumeric + underscore)
- StringLength validation ensures password meets minimum 8-character requirement
- EmailAddress validation attribute validates email format

### Next steps
- Implement user login endpoint with JWT token generation (Issue #1)
- Implement repository pattern to abstract data access from endpoints
- Add unit tests for PasswordHasher service
- Add integration tests for user registration endpoint
- Implement remaining user management endpoints (get profile, update profile, get statistics)
- Start implementing game management endpoints (create game, join game, list games)


## 2026-02-02 - Issue #1: Backend Development - Leave Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/leave endpoint for leaving games before they start
- Endpoint requires authentication (.RequireAuthorization())
- Validates game exists and is in Waiting status (cannot leave started games)
- Checks if user is actually in the game (returns 404 if not)
- Ownership transfer: If game creator leaves and other players remain, ownership transfers to next player by position
- Automatic game deletion: If last player leaves, the game is deleted
- Sets LeftAt timestamp before removing PlayerSession
- Returns 200 OK with success message
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found or user not in game), 400 Bad Request (game already started)

### Files changed
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/leave endpoint)

### Learnings
- CreatedByUserId property tracks game ownership and can be transferred when creator leaves
- EF Core Remove() on PlayerSession deletes the record from database
- Ownership transfer logic finds next player by position using OrderBy(ps => ps.Position).First()
- Game deletion when last player leaves prevents orphaned games
- LeftAt timestamp provides audit trail for player departures
- PlayerSessions.Count check before removal determines if game should be deleted
- Where clause excludes current leaving user when finding next owner
- Error scenarios: not in game (404), game already started (400), unauthorized (401)
- Testing workflow: register → login (2 users) → create game (user 1) → join game (user 2) → leave game (user 2) → verify player count reduced

### Next steps
- Implement cancel game endpoint (DELETE /api/games/{id}) - allows creator to delete game
- Implement start game endpoint (POST /api/games/{id}/start) - transitions game to InProgress and creates first round
- Test ownership transfer scenario (creator leaves, verify new owner)
- Test last player leaving scenario (verify game deletion)
- Implement game state machine for round and trick management
- Add real-time notifications for game events (gRPC/SignalR)


## 2026-02-02 - Issue #1: Backend Development - Start Game Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/start endpoint for starting games
- Endpoint requires authentication (.RequireAuthorization())
- Only allows game creator to start (returns 403 Forbidden for non-creators)
- Validates game exists and is in Waiting status (cannot start already started games)
- Validates minimum 2 players required to start game
- Randomly selects dealer from active players
- Automatically determines party player (counter-clockwise from dealer)
- Creates first Round entity with:
  - RoundNumber = 1
  - DealerUserId and PartyPlayerUserId set
  - Status = TrumpSelection (waiting for party player to select trump)
  - TrumpSuit = Hearts (default, will be changed by party player)
  - TrickValue = 0 (will be set after trump selection)
- Updates Game entity:
  - Status = InProgress
  - StartedAt timestamp
  - CurrentRoundNumber = 1
  - CurrentDealerPosition set to dealer's position
- Returns StartGameResponse with gameId, status, startedAt, currentRoundNumber, currentDealerPosition
- Error handling: 401 Unauthorized (no token), 404 Not Found (game not found), 403 Forbidden (not creator), 400 Bad Request (already started or < 2 players)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/StartGameResponse.cs (response DTO with game start details)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/start endpoint after cancel game endpoint)

### Learnings
- Random dealer selection uses Random.Next() to pick from active players
- Party player calculation: counter-clockwise means next position in circular order (dealerPosition + 1) % playerCount
- Round.Status starts at TrumpSelection, waiting for party player to choose trump
- Round.TrumpSuit has default value (Hearts) that will be overwritten during trump selection
- Round.TrickValue is 0 initially and will be set to 1, 2, or 4 after trump selection (based on suit and timing)
- Game.CurrentDealerPosition stores the position (0-4) of the current dealer for round management
- FirstOrDefaultAsync with Include() loads navigation properties needed for game state queries
- Dealer and party player selection logic handles non-sequential player positions by sorting first
- Circular indexing: (index + 1) % count wraps around to 0 when reaching end of list
- Testing workflow: register → login (2 users) → create game → join game → start game (201) → verify status (InProgress) → try start again (400)
- Edge cases tested: start with 1 player (400), start already started game (400), non-creator tries to start (403)

### Next steps
- Implement trump selection endpoint (POST /api/games/{id}/rounds/current/trump)
- Implement player decision endpoint (POST /api/games/{id}/rounds/current/play-decision)
- Implement card dealing logic (deal 2 cards initially, then 3 more after decisions)
- Implement card exchange endpoint (POST /api/games/{id}/rounds/current/exchange-cards)
- Implement play card endpoint (POST /api/games/{id}/rounds/current/play-card)
- Implement get game state endpoint (GET /api/games/{id}/state)
- Add real-time notifications for game events (gRPC/SignalR)
## 2026-02-02 - Issue #1: Backend Development - Play Card Endpoint Implementation

### What was implemented
- Implemented POST /api/games/{id}/rounds/current/play-card endpoint for trick-taking phase
- Created PlayCardRequest and PlayCardResponse DTOs with TrickWinner and RoundScore nested types
- Created TrickTakingService with comprehensive game logic:
  - ValidateCardPlay: Enforces follow suit, trump escalation, mandatory Ace of trump, and cortar (cutting) rules
  - DetermineTrickWinner: Identifies trick winner based on highest trump or highest card of lead suit
  - GetNextPlayerPosition: Calculates next player in counter-clockwise order
  - CalculateRoundScores: Computes point changes, penalties, and handles party player double penalties
  - IsGameComplete: Checks win condition (any player ≤ 0 points)
- Endpoint requires authentication (.RequireAuthorization())
- Auto-transitions from CardExchange to Playing phase when first card is played
- Validates all trick-taking rules from game rules documentation:
  - Card must be in player's hand (400 Bad Request)
  - Must follow suit if able (400 Bad Request)
  - Must play trump (cortar) when cannot follow suit and have trump (400 Bad Request)
  - Trump escalation: must play higher trump when trump is led (400 Bad Request)
  - Mandatory Ace of trump when leading or cutting (400 Bad Request)
  - Only current player can play (403 Forbidden)
- Trick management:
  - Creates Trick entity for each of 5 tricks in a round
  - Tracks cards played in JSON (PlayerSessionId + Card)
  - Party player leads first trick, subsequent tricks led by previous winner
  - Determines trick winner and sets WinnerPlayerSessionId
- Round completion (after 5 tricks):
  - Calculates scores based on tricks won × trick value
  - Applies penalties for zero tricks (5/10/20 points based on trick value)
  - Party player penalty is doubled
  - Updates PlayerSession.CurrentPoints
  - Creates ScoreHistory records with proper ScoreReason (TricksWon, NoTricksNormalPenalty, NoTricksPartyPenalty)
  - Transitions round to Completed status
- Game completion:
  - Checks if any player has ≤ 0 points
  - Sets Game status to Completed
- Response includes:
  - Trick progress (trickNumber, trickCompleted, nextPlayerPosition)
  - Trick winner details (position, userId, displayName)
  - Round completion with scores (pointsChange, pointsAfter, tricksWon, penalty flag, isPartyPlayer flag)
  - Game completion flag
- Error handling: 401 Unauthorized, 404 Not Found (game/round/player/hand), 400 Bad Request (validation), 403 Forbidden (not your turn), 409 Conflict (wrong phase)

### Files changed
- Created: backend/SobeSobe.Api/DTOs/PlayCardRequest.cs (card to play)
- Created: backend/SobeSobe.Api/DTOs/PlayCardResponse.cs (trick state, winner, scores, completion flags)
- Created: backend/SobeSobe.Api/Services/TrickTakingService.cs (comprehensive game logic service, 200+ lines)
- Modified: backend/SobeSobe.Api/Program.cs (added POST /api/games/{id}/rounds/current/play-card endpoint, registered TrickTakingService)

### Learnings
- Trick-taking validation is complex with multiple interdependent rules (follow suit, trump, Ace of trump)
- Lead suit determines whether players must follow or can cut with trump
- Trump escalation rule applies only when trump is led (must play higher trump if able)
- Mandatory Ace of trump applies when leading or cutting, but NOT when following suit
- Card validation must check: in hand → can follow suit → must trump → trump escalation → Ace of trump
- GetRankValue() in Card value object provides numeric comparison for determining winners (Ace=10, 7=9, King=8, etc.)
- Trick winner algorithm: highest trump wins, else highest card of lead suit
- Party player determined from Round.PartyPlayerUserId, mapped to PlayerSession for score calculations
- Penalty calculation: trick value 1→5 points, 2→10 points, 4→20 points; doubled for party player
- ScoreReason enum has separate values for normal vs party player penalties (NoTricksNormalPenalty, NoTricksPartyPenalty)
- ApplicationDbContext uses ScoreHistories (plural) DbSet, not ScoreHistory
- Results.Json() allows returning custom status codes with JSON body (e.g., 403 Forbidden)
- Counter-clockwise play order: OrderBy player positions, increment index with modulo wrap-around
- Auto-transition from CardExchange to Playing ensures players can start playing immediately after exchanges
- All 5 tricks tracked separately as Trick entities with winner and cards played
- Round completion triggers score calculation, ScoreHistory creation, and Game completion check
- Build succeeded, all tests pass

### Next steps
- Implement get game state endpoint (GET /api/games/{id}/state) - full game state for UI
- Implement score history endpoint (GET /api/games/{id}/scores) - complete score history
- Add real-time notifications for game events (gRPC/SignalR) - player joined, card played, trick completed, round completed
- Consider adding endpoint to start new round after current round completes
- Test complete game flow: register → login → create → join → start → select trump → deal → exchange → play all 5 tricks → verify scores


## 2026-02-03 - Issue #6: Real-time Communication - gRPC Service Implementation (Tracer Bullet)

### What was implemented
- Implemented gRPC GameEvents service for real-time bidirectional communication
- Created GameEventsService with Subscribe, SendAction, and Heartbeat RPC methods
- Fixed proto enum conflict (added ACTION_ prefix to ActionType enum values)
- Implemented authentication validation for gRPC subscribers using JWT tokens
- Created thread-safe subscriber tracking with ConcurrentDictionary and ConcurrentBag
- Subscribe endpoint validates: JWT token, game exists, user is player in game
- Sends connection confirmation event on successful subscription
- Keeps stream open until client disconnects or cancellation requested
- Static BroadcastGameEventAsync method for broadcasting events to all subscribers
- Created GameEventExtensions helper class with methods for all event types:
  - BroadcastPlayerJoinedAsync
  - BroadcastPlayerLeftAsync
  - BroadcastGameStartedAsync
  - BroadcastTrumpSelectedAsync
  - BroadcastCardPlayedAsync
  - BroadcastTrickCompletedAsync
  - BroadcastRoundCompletedAsync
  - BroadcastGameCompletedAsync
- Configured gRPC services in Program.cs with builder.Services.AddGrpc()
- Mapped gRPC service endpoint with app.MapGrpcService<GameEventsService>()
- Created comprehensive documentation (docs/grpc-realtime-events.md) with:
  - Service definition overview
  - Authentication requirements
  - Event types and payloads
  - Client implementation examples
  - Testing guide with grpcurl
  - Security considerations
  - Next steps for integration

### Files changed
- Modified: backend/SobeSobe.Api/Protos/game-events.proto (fixed enum conflict: SELECT_TRUMP → ACTION_SELECT_TRUMP, etc.)
- Modified: backend/SobeSobe.Api/SobeSobe.Api.csproj (added Protobuf item group for proto compilation)
- Created: backend/SobeSobe.Api/Services/GameEventsService.cs (gRPC service implementation, 200+ lines)
- Created: backend/SobeSobe.Api/Extensions/GameEventExtensions.cs (helper methods for broadcasting events, 200+ lines)
- Modified: backend/SobeSobe.Api/Program.cs (added gRPC services and mapped gRPC endpoint)
- Created: docs/grpc-realtime-events.md (comprehensive gRPC documentation, 8KB)

### Learnings
- Protobuf enum values must be unique across all enums in same package (C++ scoping rules)
- Adding ACTION_ prefix to ActionType enum values avoids conflicts with EventType
- gRPC service requires Grpc.AspNetCore NuGet package (version 2.71.0)
- Protobuf files compiled with <Protobuf Include="..." GrpcServices="Server" />
- IServerStreamWriter<T> used for streaming responses to clients
- ServerCallContext provides cancellation token for detecting client disconnections
- ConcurrentDictionary<string, ConcurrentBag<T>> thread-safe for tracking multiple subscribers per game
- JWT validation in gRPC uses same logic as REST API (ValidateTokenAsync with TokenValidationParameters)
- Google.Protobuf.WellKnownTypes.Timestamp.FromDateTime() converts DateTime to proto Timestamp
- RpcException with StatusCode.Unauthenticated/NotFound/PermissionDenied for error responses
- Static BroadcastGameEventAsync method allows REST endpoints to broadcast events
- MapGrpcService<T>() registers gRPC service endpoints in Minimal API
- gRPC endpoints use HTTP/2 protocol (requires HTTPS in production)
- ConcurrentBag doesn't support removal - production may need different subscriber tracking mechanism
- Heartbeat RPC keeps long-lived connections alive and detects disconnections
- SendAction RPC method placeholder - actions continue through REST API for now
- Proto file generates strongly-typed C# classes in SobeSobe.Api.Protos namespace

### Next steps
- Integrate event broadcasting into existing REST endpoints (join, leave, start, trump, play card)
- Implement SignalR hub as browser-compatible fallback (gRPC-Web alternative)
- Add connection recovery and reconnection logic documentation for clients
- Implement subscriber cleanup mechanism for long-lived games
- Add performance monitoring for gRPC streams
- Consider implementing SendAction RPC for full bidirectional communication
- Add integration tests for gRPC subscription and event broadcasting
- Test with multiple concurrent subscribers (5 players)
## 2026-02-03 - Issue #7: Testing - Fixed TrickTakingService Unit Tests

### What was implemented
- Fixed 14 failing unit tests for TrickTakingService
- Updated Card value object usage: changed Value property to Rank property (e.g., Value = "Ace" → Rank = "Ace")
- Updated DetermineTrickWinner test parameter types: changed from List<(Guid, Card)> tuples to List<CardPlayed> objects
- Updated CalculateRoundScores test parameter types: changed from List<Guid> trick winners to List<Trick> entities
- Fixed test assertions: CalculateRoundScores returns score changes only, doesn't mutate PlayerSession.CurrentPoints
- All 14 tests now pass: 3 DetermineTrickWinner tests, 4 GetNextPlayerPosition tests, 3 CalculateRoundScores tests, 3 IsGameComplete tests
- Test coverage enabled with XPlat Code Coverage

### Files changed
- Modified: backend/SobeSobe.Tests/Services/TrickTakingServiceTests.cs (updated 3 test methods, fixed Card properties and parameter types)

### Learnings
- Card record uses Rank property not Value (follows card game terminology: Ace, 7, King, Queen, Jack, 6, 5, 4, 3, 2)
- CardPlayed is a class with PlayerSessionId and Card properties, not a tuple
- Trick entity stores winner in WinnerPlayerSessionId property, used for counting tricks won
- CalculateRoundScores is a pure function - returns score deltas without mutating input PlayerSession objects
- The actual point updates happen in the play-card endpoint after CalculateRoundScores returns
- Test methods follow naming convention: MethodName_Condition_ExpectedResult()
- xUnit DisplayName attribute provides readable test names in test output
- Existing tests were comprehensive: covered trick winner logic, player rotation, scoring (normal and penalties), and game completion
- Tests verify business rules: trump beats non-trump, highest trump wins, zero-trick penalties, party player double penalties
- Build succeeds with 0 errors, all 14 tests pass

### Next steps
- Add unit tests for Card value object validation methods (IsValid, GetRankValue)
- Add unit tests for PasswordHasher service (hash generation, verification)
- Add integration tests for authentication endpoints (register, login, refresh, logout)
- Add integration tests for game management endpoints (create, join, leave, start)
- Add integration tests for game action endpoints (trump selection, play decision, card exchange, play card)
- Measure code coverage percentage and target 80%+ for game logic
- Add performance tests for concurrent game scenarios
## 2026-02-03 - Issue #7: Testing - Added Unit Tests for Card and PasswordHasher

### What was implemented
- Added 33 unit tests for Card value object (backend/SobeSobe.Tests/ValueObjects/CardTests.cs)
- Added 22 unit tests for PasswordHasher service (backend/SobeSobe.Tests/Services/PasswordHasherTests.cs)
- Removed placeholder test file (UnitTest1.cs)
- All 69 unit tests pass successfully (14 TrickTakingService + 33 Card + 22 PasswordHasher)

**Card value object tests (33 total):**
- IsValid validation: 6 tests (valid card, invalid suit, invalid rank, all valid suits theory, all valid ranks theory)
- GetRankValue ranking: 11 tests (Ace highest=10, 7 second=9, 2 lowest=1, all ranks theory, invalid rank=0)
- ToString formatting: 1 test (formatted card string)
- Record equality: 3 tests (same values equal, different suit not equal, different rank not equal)

**PasswordHasher service tests (22 total):**
- HashPassword generation: 5 tests (non-empty hash, different hashes for same password, 48-byte hash format, various password formats theory)
- VerifyPassword validation: 9 tests (correct password, incorrect password, case-sensitive, various formats theory, empty password, invalid hash format, too short hash)
- Integration workflows: 2 tests (hash and verify end-to-end, multiple hashes verify correctly)

### Files changed
- Created: backend/SobeSobe.Tests/ValueObjects/CardTests.cs (33 tests covering all Card methods and properties)
- Created: backend/SobeSobe.Tests/Services/PasswordHasherTests.cs (22 tests covering hash generation and verification)
- Deleted: backend/SobeSobe.Tests/UnitTest1.cs (placeholder test file)

### Learnings
- PasswordHasher is a static class with static methods (HashPassword, VerifyPassword)
- Card record type provides automatic value equality (== operator works for value comparison)
- Record types are immutable by design (with init accessors)
- PBKDF2 hash format: 16-byte salt + 32-byte hash = 48 bytes total (encoded as base64 string)
- Different salts generated for each password hash ensure rainbow table resistance
- GetRankValue returns 0 for invalid ranks (defensive programming)
- xUnit Theory tests with InlineData allow parameterized testing (all suits, all ranks, various password formats)
- Test method DisplayName attribute provides human-readable test names in output
- Tests verify security properties: case-sensitivity, salt uniqueness, constant-time comparison
- All 69 unit tests run in <1 second (fast test execution)

### Next steps
- Add unit tests for CardDealingService (deck creation, shuffling, dealing logic)
- Add integration tests for authentication endpoints (register, login, refresh, logout)
- Add integration tests for game management endpoints (create, join, leave, start)
- Add integration tests for game action endpoints (trump selection, play decision, card exchange, play card)
- Measure code coverage percentage with reportgenerator tool (target 80%+)
- Add performance tests for concurrent game scenarios
- Set up code coverage reporting in CI/CD pipeline
